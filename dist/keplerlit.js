/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["keplerlit"] = factory();
	else
		root["keplerlit"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/BaseOverlay.ts":
/*!****************************!*\
  !*** ./src/BaseOverlay.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports) {

eval("{\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BaseOverlay = void 0;\r\nvar BaseOverlay = /** @class */ (function () {\r\n    function BaseOverlay(options) {\r\n        this.animationId = null;\r\n        this.isVisible = true;\r\n        this.canvas = options.canvas;\r\n        // Create overlay canvas\r\n        this.overlayCanvas = document.createElement('canvas');\r\n        this.overlayCanvas.width = this.canvas.width;\r\n        this.overlayCanvas.height = this.canvas.height;\r\n        this.overlayCanvas.style.position = 'absolute';\r\n        this.overlayCanvas.style.top = '0';\r\n        this.overlayCanvas.style.left = '0';\r\n        this.overlayCanvas.style.pointerEvents = 'none'; // Allow interaction with underlying canvas\r\n        this.overlayCanvas.style.zIndex = '1000';\r\n        // Position overlay on top of main canvas\r\n        if (this.canvas.parentElement) {\r\n            var parent_1 = this.canvas.parentElement;\r\n            if (getComputedStyle(parent_1).position === 'static') {\r\n                parent_1.style.position = 'relative';\r\n            }\r\n            parent_1.appendChild(this.overlayCanvas);\r\n        }\r\n        else {\r\n            document.body.appendChild(this.overlayCanvas);\r\n        }\r\n        var ctx = this.overlayCanvas.getContext('2d');\r\n        if (!ctx) {\r\n            throw new Error('Unable to get 2D context from overlay canvas');\r\n        }\r\n        this.ctx = ctx;\r\n        // Set default values - updated for scientific appearance\r\n        this.options = __assign({ fontSize: 11, fontFamily: 'Arial, sans-serif', textColor: '#333333', backgroundColor: 'rgba(255, 255, 255, 0.95)', borderColor: '#cccccc', borderWidth: 1, labelOffset: 25, precision: 1 }, options);\r\n        this.render();\r\n    }\r\n    BaseOverlay.prototype.formatValue = function (value, precision) {\r\n        // Better formatting for scientific values\r\n        if (Math.abs(value) >= 1000 || (Math.abs(value) < 0.01 && value !== 0)) {\r\n            return value.toExponential(1);\r\n        }\r\n        else if (value % 1 === 0 && Math.abs(value) < 100) {\r\n            return value.toString();\r\n        }\r\n        else {\r\n            return value.toFixed(precision);\r\n        }\r\n    };\r\n    BaseOverlay.prototype.render = function () {\r\n        if (!this.isVisible)\r\n            return;\r\n        // Clear overlay canvas\r\n        this.ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);\r\n    };\r\n    // Update methods\r\n    BaseOverlay.prototype.updatePosition = function (x, y) {\r\n        this.options.x = x;\r\n        this.options.y = y;\r\n        this.render();\r\n    };\r\n    BaseOverlay.prototype.updateSize = function (width, height) {\r\n        this.options.width = width;\r\n        this.options.height = height;\r\n        this.render();\r\n    };\r\n    // Handle canvas resize\r\n    BaseOverlay.prototype.resize = function (width, height) {\r\n        this.overlayCanvas.width = width;\r\n        this.overlayCanvas.height = height;\r\n        this.render();\r\n    };\r\n    // Cleanup method\r\n    BaseOverlay.prototype.destroy = function () {\r\n        if (this.animationId) {\r\n            cancelAnimationFrame(this.animationId);\r\n        }\r\n        if (this.overlayCanvas.parentElement) {\r\n            this.overlayCanvas.parentElement.removeChild(this.overlayCanvas);\r\n        }\r\n    };\r\n    // Show/hide methods\r\n    BaseOverlay.prototype.show = function () {\r\n        this.isVisible = true;\r\n        this.overlayCanvas.style.display = 'block';\r\n        this.render();\r\n    };\r\n    BaseOverlay.prototype.hide = function () {\r\n        this.isVisible = false;\r\n        this.overlayCanvas.style.display = 'none';\r\n    };\r\n    BaseOverlay.prototype.toggle = function () {\r\n        if (this.isVisible) {\r\n            this.hide();\r\n        }\r\n        else {\r\n            this.show();\r\n        }\r\n    };\r\n    // Method to redraw (useful for animation loops)\r\n    BaseOverlay.prototype.redraw = function () {\r\n        this.render();\r\n    };\r\n    // Getters for current state\r\n    BaseOverlay.prototype.getOptions = function () {\r\n        return __assign({}, this.options);\r\n    };\r\n    BaseOverlay.prototype.isShown = function () {\r\n        return this.isVisible;\r\n    };\r\n    return BaseOverlay;\r\n}());\r\nexports.BaseOverlay = BaseOverlay;\r\n\n\n//# sourceURL=webpack://keplerlit/./src/BaseOverlay.ts?\n}");

/***/ }),

/***/ "./src/Color.ts":
/*!**********************!*\
  !*** ./src/Color.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("{\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Color = void 0;\r\nvar Color = /** @class */ (function () {\r\n    function Color(colorOrRgb) {\r\n        if (!colorOrRgb) {\r\n            // Default to black\r\n            this.r = 0;\r\n            this.g = 0;\r\n            this.b = 0;\r\n        }\r\n        else if (Array.isArray(colorOrRgb)) {\r\n            // Array of 3 numbers\r\n            if (colorOrRgb.length !== 3) {\r\n                throw new Error('RGB array must have exactly 3 elements');\r\n            }\r\n            this.r = colorOrRgb[0];\r\n            this.g = colorOrRgb[1];\r\n            this.b = colorOrRgb[2];\r\n        }\r\n        else if (typeof colorOrRgb === 'string') {\r\n            // Hex string\r\n            if (!/^#([0-9A-F]{3}|[0-9A-F]{6})$/i.test(colorOrRgb)) {\r\n                throw new Error('Invalid hex color format');\r\n            }\r\n            this.setHex(colorOrRgb);\r\n        }\r\n        else if (typeof colorOrRgb === 'number') {\r\n            // Color object\r\n            // this.r = (colorOrRgb as Color).r\r\n            // this.g = (colorOrRgb as Color).g\r\n            // this.b = (colorOrRgb as Color).b\r\n            // throw new Error('Invalid hex color format')\r\n            this.setHex(Color.toHexString(colorOrRgb));\r\n        }\r\n        else if (typeof colorOrRgb === 'number') {\r\n            // Color object\r\n            // this.r = (colorOrRgb as Color).r\r\n            // this.g = (colorOrRgb as Color).g\r\n            // this.b = (colorOrRgb as Color).b\r\n            // throw new Error('Invalid hex color format')\r\n            this.setHex(Color.toHexString(colorOrRgb));\r\n        }\r\n        else if (typeof colorOrRgb === 'object') {\r\n            // Color object\r\n            this.r = colorOrRgb.r;\r\n            this.g = colorOrRgb.g;\r\n            this.b = colorOrRgb.b;\r\n        }\r\n        else {\r\n            throw new Error(\"Invalid color format. Must be an array of 3 numbers, a hex string, or a Color instance. Got \".concat(colorOrRgb));\r\n        }\r\n    }\r\n    Color.prototype.lerp = function (color, t) {\r\n        // console.log(this.r, this.g, this.b, color.r, color.g, color.b, t)\r\n        // console.log(this.r + (color.r - this.r) * t, this.g + (color.g - this.g) * t, this.b + (color.b - this.b) * t)\r\n        // console.log('---')\r\n        if (t < 0 || t > 1) {\r\n            throw new Error('Interpolation factor t must be between 0 and 1');\r\n        }\r\n        if (!(color instanceof Color)) {\r\n            throw new Error('Argument must be an instance of Color');\r\n        }\r\n        return new Color({\r\n            r: this.r + (color.r - this.r) * t,\r\n            g: this.g + (color.g - this.g) * t,\r\n            b: this.b + (color.b - this.b) * t\r\n        });\r\n    };\r\n    Color.toHexString = function (color) {\r\n        return '#' + (color & 0xFFFFFF).toString(16).padStart(6, '0').toUpperCase();\r\n    };\r\n    Color.prototype.toHex = function () {\r\n        var r = Math.round(this.r * 255).toString(16).padStart(2, '0');\r\n        var g = Math.round(this.g * 255).toString(16).padStart(2, '0');\r\n        var b = Math.round(this.b * 255).toString(16).padStart(2, '0');\r\n        return \"#\".concat(r).concat(g).concat(b);\r\n    };\r\n    /**\r\n     * Set from hex string\r\n     */\r\n    Color.prototype.setHex = function (hex) {\r\n        hex = hex.replace('#', '');\r\n        if (hex.length !== 6) {\r\n            throw new Error('Invalid hex color format');\r\n        }\r\n        this.r = parseInt(hex.substring(0, 2), 16) / 255;\r\n        this.g = parseInt(hex.substring(2, 4), 16) / 255;\r\n        this.b = parseInt(hex.substring(4, 6), 16) / 255;\r\n        return this;\r\n    };\r\n    return Color;\r\n}());\r\nexports.Color = Color;\r\n\n\n//# sourceURL=webpack://keplerlit/./src/Color.ts?\n}");

/***/ }),

/***/ "./src/ColorScale.ts":
/*!***************************!*\
  !*** ./src/ColorScale.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ColorScale = void 0;\r\nvar BaseOverlay_1 = __webpack_require__(/*! ./BaseOverlay */ \"./src/BaseOverlay.ts\");\r\nvar ColorScale = /** @class */ (function (_super) {\r\n    __extends(ColorScale, _super);\r\n    function ColorScale(options) {\r\n        var _this = _super.call(this, options) || this;\r\n        // Set default values - updated for scientific appearance\r\n        _this.options = __assign({ fontSize: 11, fontFamily: 'Arial, sans-serif', textColor: '#333333', backgroundColor: 'rgba(255, 255, 255, 0.95)', borderColor: '#cccccc', borderWidth: 1, labelOffset: 25, precision: 1 }, options);\r\n        _this.render();\r\n        return _this;\r\n    }\r\n    // Method to get color at specific value\r\n    ColorScale.prototype.getColorAtValue = function (value) {\r\n        var _a = this.options, min = _a.min, max = _a.max, colorStops = _a.colorStops;\r\n        // Normalize value to 0-1 range\r\n        var normalizedValue = Math.max(0, Math.min(1, (value - min) / (max - min)));\r\n        // Find the appropriate color stops\r\n        var sortedStops = __spreadArray([], colorStops, true).sort(function (a, b) { return a.position - b.position; });\r\n        if (normalizedValue <= sortedStops[0].position) {\r\n            return sortedStops[0].color;\r\n        }\r\n        if (normalizedValue >= sortedStops[sortedStops.length - 1].position) {\r\n            return sortedStops[sortedStops.length - 1].color;\r\n        }\r\n        // Interpolate between two stops\r\n        for (var i = 0; i < sortedStops.length - 1; i++) {\r\n            var stop1 = sortedStops[i];\r\n            var stop2 = sortedStops[i + 1];\r\n            if (normalizedValue >= stop1.position && normalizedValue <= stop2.position) {\r\n                var t = (normalizedValue - stop1.position) / (stop2.position - stop1.position);\r\n                return this.interpolateColor(stop1.color, stop2.color, t);\r\n            }\r\n        }\r\n        return sortedStops[0].color;\r\n    };\r\n    ColorScale.prototype.updateRange = function (min, max) {\r\n        this.options.min = min;\r\n        this.options.max = max;\r\n        this.render();\r\n    };\r\n    ColorScale.prototype.updateColorStops = function (colorStops) {\r\n        this.options.colorStops = colorStops;\r\n        this.render();\r\n    };\r\n    ColorScale.prototype.updateOrientation = function (orientation) {\r\n        this.options.orientation = orientation;\r\n        this.render();\r\n    };\r\n    ColorScale.prototype.updateAttributeName = function (name) {\r\n        this.options.attributeName = name;\r\n        this.render();\r\n    };\r\n    // Getters for current state\r\n    ColorScale.prototype.getOptions = function () {\r\n        return __assign({}, this.options);\r\n    };\r\n    // @override\r\n    ColorScale.prototype.render = function () {\r\n        if (!this.isVisible)\r\n            return;\r\n        _super.prototype.render.call(this);\r\n        this.drawScale();\r\n        this.drawLabels();\r\n    };\r\n    // -------------------------------------------------------\r\n    ColorScale.prototype.interpolateColor = function (color1, color2, t) {\r\n        // Simple RGB interpolation\r\n        var c1 = this.hexToRgb(color1);\r\n        var c2 = this.hexToRgb(color2);\r\n        if (!c1 || !c2)\r\n            return color1;\r\n        var r = Math.round(c1.r + (c2.r - c1.r) * t);\r\n        var g = Math.round(c1.g + (c2.g - c1.g) * t);\r\n        var b = Math.round(c1.b + (c2.b - c1.b) * t);\r\n        return \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\");\r\n    };\r\n    ColorScale.prototype.hexToRgb = function (hex) {\r\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n        return result ? {\r\n            r: parseInt(result[1], 16),\r\n            g: parseInt(result[2], 16),\r\n            b: parseInt(result[3], 16)\r\n        } : null;\r\n    };\r\n    ColorScale.prototype.createGradient = function () {\r\n        var _a = this.options, x = _a.x, y = _a.y, width = _a.width, height = _a.height, orientation = _a.orientation, colorStops = _a.colorStops;\r\n        var gradient;\r\n        if (orientation === 'vertical') {\r\n            gradient = this.ctx.createLinearGradient(0, y + height, 0, y);\r\n        }\r\n        else {\r\n            gradient = this.ctx.createLinearGradient(x, 0, x + width, 0);\r\n        }\r\n        // Sort color stops by position\r\n        var sortedStops = __spreadArray([], colorStops, true).sort(function (a, b) { return a.position - b.position; });\r\n        for (var _i = 0, sortedStops_1 = sortedStops; _i < sortedStops_1.length; _i++) {\r\n            var stop_1 = sortedStops_1[_i];\r\n            gradient.addColorStop(stop_1.position, stop_1.color);\r\n        }\r\n        return gradient;\r\n    };\r\n    ColorScale.prototype.drawScale = function () {\r\n        var _a = this.options, x = _a.x, y = _a.y, width = _a.width, height = _a.height, backgroundColor = _a.backgroundColor, borderColor = _a.borderColor, borderWidth = _a.borderWidth;\r\n        this.ctx.save();\r\n        // Draw background with slight padding and rounded corners\r\n        if (backgroundColor !== 'transparent') {\r\n            var padding = 1;\r\n            this.ctx.fillStyle = backgroundColor;\r\n            this.roundRect(x - padding, y - padding, width + padding * 2, height + padding * 2, 1);\r\n            this.ctx.fill();\r\n        }\r\n        // Draw gradient with subtle inner shadow effect\r\n        var gradient = this.createGradient();\r\n        this.ctx.fillStyle = gradient;\r\n        this.roundRect(x, y, width, height, 1);\r\n        this.ctx.fill();\r\n        // Draw subtle border\r\n        if (borderWidth > 0) {\r\n            this.ctx.strokeStyle = borderColor;\r\n            this.ctx.lineWidth = borderWidth;\r\n            this.roundRect(x, y, width, height, 1);\r\n            this.ctx.stroke();\r\n        }\r\n        // Add tick marks for better scientific appearance\r\n        this.drawTickMarks();\r\n        this.ctx.restore();\r\n    };\r\n    ColorScale.prototype.roundRect = function (x, y, width, height, radius) {\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(x + radius, y);\r\n        this.ctx.lineTo(x + width - radius, y);\r\n        this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n        this.ctx.lineTo(x + width, y + height - radius);\r\n        this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n        this.ctx.lineTo(x + radius, y + height);\r\n        this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n        this.ctx.lineTo(x, y + radius);\r\n        this.ctx.quadraticCurveTo(x, y, x + radius, y);\r\n        this.ctx.closePath();\r\n    };\r\n    ColorScale.prototype.drawTickMarks = function () {\r\n        var _a = this.options, x = _a.x, y = _a.y, width = _a.width, height = _a.height, orientation = _a.orientation, borderColor = _a.borderColor;\r\n        var tickCount = 5;\r\n        var tickLength = 4;\r\n        this.ctx.strokeStyle = borderColor;\r\n        this.ctx.lineWidth = 1;\r\n        for (var i = 0; i <= tickCount; i++) {\r\n            var position = i / tickCount;\r\n            if (orientation === 'vertical') {\r\n                var tickY = y + height - (position * height);\r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(x + width, tickY);\r\n                this.ctx.lineTo(x + width + tickLength, tickY);\r\n                this.ctx.stroke();\r\n            }\r\n            else {\r\n                var tickX = x + (position * width);\r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(tickX, y + height);\r\n                this.ctx.lineTo(tickX, y + height + tickLength);\r\n                this.ctx.stroke();\r\n            }\r\n        }\r\n    };\r\n    ColorScale.prototype.drawLabels = function () {\r\n        var _a = this.options, x = _a.x, y = _a.y, width = _a.width, height = _a.height, min = _a.min, max = _a.max, orientation = _a.orientation, fontSize = _a.fontSize, fontFamily = _a.fontFamily, textColor = _a.textColor, labelOffset = _a.labelOffset, precision = _a.precision, attributeName = _a.attributeName;\r\n        this.ctx.save();\r\n        this.ctx.fillStyle = textColor;\r\n        this.ctx.font = \"\".concat(fontSize, \"px \").concat(fontFamily);\r\n        // Draw intermediate values for more scientific appearance\r\n        var valueCount = 5;\r\n        var tickOffset = 8;\r\n        if (orientation === 'vertical') {\r\n            // Draw attribute name\r\n            this.ctx.save();\r\n            this.ctx.translate(x + width + labelOffset + fontSize * 2, y + height / 2);\r\n            this.ctx.rotate(Math.PI / 2);\r\n            this.ctx.textAlign = 'center';\r\n            this.ctx.textBaseline = 'middle';\r\n            this.ctx.fillText(attributeName, 0, 0);\r\n            this.ctx.restore();\r\n            // Draw scale values\r\n            this.ctx.textAlign = 'left';\r\n            this.ctx.textBaseline = 'middle';\r\n            for (var i = 0; i <= valueCount; i++) {\r\n                var position = i / valueCount;\r\n                var value = min + (max - min) * (1 - position); // Inverted for vertical\r\n                var labelY = y + position * height;\r\n                var formattedValue = this.formatValue(value, precision);\r\n                this.ctx.fillText(formattedValue, x + width + tickOffset, labelY);\r\n            }\r\n        }\r\n        else {\r\n            // Horizontal orientation\r\n            this.ctx.textAlign = 'center';\r\n            this.ctx.textBaseline = 'top';\r\n            this.ctx.fillText(attributeName, x + width / 2, y - labelOffset - fontSize);\r\n            // Draw scale values\r\n            this.ctx.textBaseline = 'top';\r\n            for (var i = 0; i <= valueCount; i++) {\r\n                var position = i / valueCount;\r\n                var value = min + (max - min) * position;\r\n                var labelX = x + position * width;\r\n                var formattedValue = this.formatValue(value, precision);\r\n                this.ctx.fillText(formattedValue, labelX, y + height + tickOffset);\r\n            }\r\n        }\r\n        this.ctx.restore();\r\n    };\r\n    return ColorScale;\r\n}(BaseOverlay_1.BaseOverlay));\r\nexports.ColorScale = ColorScale;\r\n\n\n//# sourceURL=webpack://keplerlit/./src/ColorScale.ts?\n}");

/***/ }),

/***/ "./src/Compass2D.ts":
/*!**************************!*\
  !*** ./src/Compass2D.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Compass2D = void 0;\r\nvar BaseOverlay_1 = __webpack_require__(/*! ./BaseOverlay */ \"./src/BaseOverlay.ts\");\r\n/**\r\n * @brief A class to create a compass rose on an HTML canvas with navigation capabilities.\r\n * @param {HTMLCanvasElement} canvas - The canvas element to draw on.\r\n * @param {Object} [options] - Configuration options for the compass.\r\n * @param {number} [options.x=100] - The x-coordinate of the compass center.\r\n * @param {number} [options.y=100] - The y-coordinate of the compass center.\r\n * @param {number} [options.size=60] - The size of the compass.\r\n * @param {number} [options.cameraAngle=0] - The angle of the camera in degrees.\r\n * @param {number} [options.opacity=0.9] - The opacity of the compass.\r\n * @param {boolean} [options.visible=true] - Whether the compass is visible.\r\n * @param {Object} [options.colors] - Custom colors for the compass.\r\n * @param {string} [options.colors.primary='#ff4444'] - Primary color for the compass.\r\n * @param {string} [options.colors.secondary='#ffffff'] - Secondary color for the compass.\r\n * @param {string} [options.colors.accent='#ffaa00'] - Accent color for the compass.\r\n * @param {string} [options.colors.background='rgba(0,0,0,0.4)'] - Background color for the compass.\r\n * @param {string} [options.colors.text='#ffffff'] - Text color for the compass labels.\r\n */\r\nvar Compass2D = /** @class */ (function (_super) {\r\n    __extends(Compass2D, _super);\r\n    function Compass2D(options) {\r\n        var _this = this;\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        var _j, _k, _l, _m, _o;\r\n        _this = _super.call(this, options) || this;\r\n        _this.options = __assign({ width: 200, height: 200, x: 100, y: 100, fontSize: 11, fontFamily: 'Arial, sans-serif', textColor: '#333333', backgroundColor: 'rgba(255, 255, 255, 0.95)', borderColor: '#cccccc', borderWidth: 1, labelOffset: 25, precision: 1, cameraAngle: (_a = options.cameraAngle) !== null && _a !== void 0 ? _a : (options.cameraAngle = 45), opacity: (_b = options.opacity) !== null && _b !== void 0 ? _b : (options.opacity = 0.9), visible: (_c = options.visible) !== null && _c !== void 0 ? _c : (options.visible = true), colors: {\r\n                primary: (_d = (_j = options.colors).primary) !== null && _d !== void 0 ? _d : (_j.primary = '#ff4444'),\r\n                secondary: (_e = (_k = options.colors).secondary) !== null && _e !== void 0 ? _e : (_k.secondary = '#ffffff'),\r\n                accent: (_f = (_l = options.colors).accent) !== null && _f !== void 0 ? _f : (_l.accent = '#ffaa00'),\r\n                background: (_g = (_m = options.colors).background) !== null && _g !== void 0 ? _g : (_m.background = 'rgba(0,0,0,0.4)'),\r\n                text: (_h = (_o = options.colors).text) !== null && _h !== void 0 ? _h : (_o.text = '#ffffff'),\r\n            } }, options);\r\n        _this.canvas.width = window.innerWidth;\r\n        _this.canvas.height = window.innerHeight;\r\n        _this.render();\r\n        return _this;\r\n    }\r\n    Compass2D.prototype.setPosition = function (x, y) {\r\n        this.options.x = x;\r\n        this.options.y = y;\r\n    };\r\n    Compass2D.prototype.setPositionByName = function (positionName) {\r\n        var margin = this.options.width + 20;\r\n        switch (positionName) {\r\n            case 'top-right':\r\n                this.setPosition(this.canvas.width - margin, margin);\r\n                break;\r\n            case 'top-left':\r\n                this.setPosition(margin, margin);\r\n                break;\r\n            case 'bottom-right':\r\n                this.setPosition(this.canvas.width - margin, this.canvas.height - margin);\r\n                break;\r\n            case 'bottom-left':\r\n                this.setPosition(margin, this.canvas.height - margin);\r\n                break;\r\n            case 'center':\r\n                this.setPosition(this.canvas.width / 2, this.canvas.height / 2);\r\n                break;\r\n        }\r\n    };\r\n    // setupCanvas() {\r\n    //     this.canvas.width = window.innerWidth\r\n    //     this.canvas.height = window.innerHeight\r\n    // }\r\n    // setSize(size: number) {\r\n    //     this.options.width = size\r\n    // }\r\n    Compass2D.prototype.setCameraAngle = function (angle) {\r\n        this.options.cameraAngle = angle;\r\n    };\r\n    Compass2D.prototype.setOpacity = function (opacity) {\r\n        this.options.opacity = opacity;\r\n    };\r\n    Compass2D.prototype.setVisible = function (visible) {\r\n        this.options.visible = visible;\r\n    };\r\n    /**\r\n     * Set a callback function that will be called when orientation changes\r\n     * @param callback Function to call with direction and angle parameters\r\n     */\r\n    Compass2D.prototype.setOrientationCallback = function (callback) {\r\n        this.onOrientationChange = callback;\r\n    };\r\n    /**\r\n     * Get the angle for a cardinal direction\r\n     * @param direction The cardinal direction\r\n     * @returns The angle in degrees (0Â° = North, clockwise)\r\n     */\r\n    Compass2D.prototype.getDirectionAngle = function (direction) {\r\n        var directions = {\r\n            'N': 0,\r\n            'NE': 45,\r\n            'E': 90,\r\n            'SE': 135,\r\n            'S': 180,\r\n            'SW': 225,\r\n            'W': 270,\r\n            'NW': 315,\r\n            'center': this.options.cameraAngle // Keep current angle for center\r\n        };\r\n        return directions[direction];\r\n    };\r\n    /**\r\n     * Get the current cardinal direction based on camera angle\r\n     * @returns The closest cardinal direction\r\n     */\r\n    Compass2D.prototype.getCurrentDirection = function () {\r\n        var normalizedAngle = ((this.options.cameraAngle % 360) + 360) % 360;\r\n        if (normalizedAngle >= 337.5 || normalizedAngle < 22.5)\r\n            return 'N';\r\n        if (normalizedAngle >= 22.5 && normalizedAngle < 67.5)\r\n            return 'NE';\r\n        if (normalizedAngle >= 67.5 && normalizedAngle < 112.5)\r\n            return 'E';\r\n        if (normalizedAngle >= 112.5 && normalizedAngle < 157.5)\r\n            return 'SE';\r\n        if (normalizedAngle >= 157.5 && normalizedAngle < 202.5)\r\n            return 'S';\r\n        if (normalizedAngle >= 202.5 && normalizedAngle < 247.5)\r\n            return 'SW';\r\n        if (normalizedAngle >= 247.5 && normalizedAngle < 292.5)\r\n            return 'W';\r\n        if (normalizedAngle >= 292.5 && normalizedAngle < 337.5)\r\n            return 'NW';\r\n        return 'N'; // Default fallback\r\n    };\r\n    /**\r\n     * Orient the compass (and trigger camera orientation) to a specific cardinal direction\r\n     * @param direction The cardinal direction to orient to\r\n     * @param smooth Whether to animate the transition (default: true)\r\n     */\r\n    Compass2D.prototype.orientToDirection = function (direction, smooth) {\r\n        if (smooth === void 0) { smooth = true; }\r\n        var targetAngle = this.getDirectionAngle(direction);\r\n        if (smooth) {\r\n            this.animateToAngle(targetAngle);\r\n        }\r\n        else {\r\n            this.setCameraAngle(targetAngle);\r\n            this.render();\r\n        }\r\n        // Trigger the orientation callback if set\r\n        if (this.onOrientationChange) {\r\n            this.onOrientationChange(direction, targetAngle);\r\n        }\r\n    };\r\n    /**\r\n     * Smoothly animate the compass to a target angle\r\n     * @param targetAngle The target angle in degrees\r\n     * @param duration The animation duration in milliseconds (default: 1000)\r\n     */\r\n    Compass2D.prototype.animateToAngle = function (targetAngle, duration) {\r\n        var _this = this;\r\n        if (duration === void 0) { duration = 1000; }\r\n        var startAngle = this.options.cameraAngle;\r\n        var startTime = Date.now();\r\n        // Calculate the shortest rotation path\r\n        var angleDiff = targetAngle - startAngle;\r\n        if (angleDiff > 180)\r\n            angleDiff -= 360;\r\n        if (angleDiff < -180)\r\n            angleDiff += 360;\r\n        var animate = function () {\r\n            var elapsed = Date.now() - startTime;\r\n            var progress = Math.min(elapsed / duration, 1);\r\n            // Easing function (ease-in-out)\r\n            var easeProgress = progress < 0.5\r\n                ? 2 * progress * progress\r\n                : 1 - Math.pow(-2 * progress + 2, 2) / 2;\r\n            var currentAngle = startAngle + (angleDiff * easeProgress);\r\n            _this.setCameraAngle(currentAngle);\r\n            _this.render();\r\n            if (progress < 1) {\r\n                requestAnimationFrame(animate);\r\n            }\r\n        };\r\n        animate();\r\n    };\r\n    /**\r\n     * Get a list of all available cardinal directions\r\n     * @returns Array of cardinal direction strings\r\n     */\r\n    Compass2D.prototype.getAvailableDirections = function () {\r\n        return ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'center'];\r\n    };\r\n    Compass2D.prototype.drawArrow = function (angle, length, color, width) {\r\n        if (width === void 0) { width = 2; }\r\n        var ctx = this.ctx;\r\n        if (!ctx)\r\n            return;\r\n        var radians = (angle + this.options.cameraAngle) * Math.PI / 180;\r\n        var endX = this.options.x + Math.cos(radians) * length;\r\n        var endY = this.options.y + Math.sin(radians) * length;\r\n        ctx.save();\r\n        ctx.globalAlpha = this.options.opacity;\r\n        ctx.strokeStyle = color;\r\n        ctx.fillStyle = color;\r\n        ctx.lineWidth = width;\r\n        ctx.lineCap = 'round';\r\n        // Draw arrow shaft\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.options.x, this.options.y);\r\n        ctx.lineTo(endX, endY);\r\n        ctx.stroke();\r\n        // Draw arrowhead\r\n        var headLength = length * 0.25;\r\n        var headAngle = Math.PI / 6;\r\n        ctx.beginPath();\r\n        ctx.moveTo(endX, endY);\r\n        ctx.lineTo(endX - headLength * Math.cos(radians - headAngle), endY - headLength * Math.sin(radians - headAngle));\r\n        ctx.moveTo(endX, endY);\r\n        ctx.lineTo(endX - headLength * Math.cos(radians + headAngle), endY - headLength * Math.sin(radians + headAngle));\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    };\r\n    Compass2D.prototype.drawDirectionLabel = function (angle, text, distance) {\r\n        var ctx = this.ctx;\r\n        if (!ctx)\r\n            return;\r\n        var radians = (angle + this.options.cameraAngle) * Math.PI / 180;\r\n        var labelX = this.options.x + Math.cos(radians) * distance;\r\n        var labelY = this.options.y + Math.sin(radians) * distance;\r\n        ctx.save();\r\n        ctx.globalAlpha = this.options.opacity;\r\n        ctx.fillStyle = this.options.colors.text;\r\n        ctx.font = \"bold \".concat(this.options.width * 0.2, \"px Arial\");\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        // Add text shadow for better readability\r\n        ctx.shadowColor = 'rgba(0,0,0,0.8)';\r\n        ctx.shadowBlur = 2;\r\n        ctx.shadowOffsetX = 1;\r\n        ctx.shadowOffsetY = 1;\r\n        ctx.fillText(text, labelX, labelY);\r\n        ctx.restore();\r\n    };\r\n    Compass2D.prototype.drawTicks = function () {\r\n        var ctx = this.ctx;\r\n        if (!ctx)\r\n            return;\r\n        ctx.save();\r\n        ctx.globalAlpha = this.options.opacity * 0.7;\r\n        // Draw major ticks (every 45 degrees)\r\n        for (var i = 0; i < 360; i += 45) {\r\n            var radians = (i + this.options.cameraAngle) * Math.PI / 180;\r\n            var innerRadius = this.options.width * 0.7;\r\n            var outerRadius = this.options.width * 0.85;\r\n            var x1 = this.options.x + Math.cos(radians) * innerRadius;\r\n            var y1 = this.options.y + Math.sin(radians) * innerRadius;\r\n            var x2 = this.options.x + Math.cos(radians) * outerRadius;\r\n            var y2 = this.options.y + Math.sin(radians) * outerRadius;\r\n            ctx.strokeStyle = this.options.colors.secondary;\r\n            ctx.lineWidth = 1.5;\r\n            ctx.beginPath();\r\n            ctx.moveTo(x1, y1);\r\n            ctx.lineTo(x2, y2);\r\n            ctx.stroke();\r\n        }\r\n        ctx.restore();\r\n    };\r\n    Compass2D.prototype.drawBackground = function () {\r\n        var ctx = this.ctx;\r\n        if (!ctx)\r\n            return;\r\n        ctx.save();\r\n        ctx.globalAlpha = this.options.opacity;\r\n        // Draw compass background circle\r\n        ctx.fillStyle = this.options.colors.background;\r\n        ctx.strokeStyle = this.options.colors.secondary;\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        ctx.arc(this.options.x, this.options.y, this.options.width, 0, 2 * Math.PI);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        // Draw center dot\r\n        ctx.fillStyle = this.options.colors.accent;\r\n        ctx.beginPath();\r\n        ctx.arc(this.options.x, this.options.y, 3, 0, 2 * Math.PI);\r\n        ctx.fill();\r\n        ctx.restore();\r\n    };\r\n    Compass2D.prototype.render = function () {\r\n        if (!this.options.visible || !this.ctx)\r\n            return;\r\n        _super.prototype.render.call(this);\r\n        // Clear overlay canvas\r\n        // this.ctx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);\r\n        // Draw compass components\r\n        this.drawBackground();\r\n        this.drawTicks();\r\n        // Draw cardinal directions\r\n        this.drawArrow(0, this.options.width * 0.6, this.options.colors.primary, 3); // North\r\n        this.drawArrow(180, this.options.width * 0.5, this.options.colors.secondary, 2); // South\r\n        this.drawArrow(90, this.options.width * 0.5, this.options.colors.secondary, 2); // East\r\n        this.drawArrow(270, this.options.width * 0.5, this.options.colors.secondary, 2); // West\r\n        // Draw direction labels\r\n        var labelDistance = this.options.width * 1.15;\r\n        this.drawDirectionLabel(0, 'N', labelDistance);\r\n        this.drawDirectionLabel(90, 'E', labelDistance);\r\n        this.drawDirectionLabel(180, 'S', labelDistance);\r\n        this.drawDirectionLabel(270, 'W', labelDistance);\r\n    };\r\n    return Compass2D;\r\n}(BaseOverlay_1.BaseOverlay));\r\nexports.Compass2D = Compass2D;\r\n\n\n//# sourceURL=webpack://keplerlit/./src/Compass2D.ts?\n}");

/***/ }),

/***/ "./src/IsoContoursFilled.ts":
/*!**********************************!*\
  !*** ./src/IsoContoursFilled.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.IsoContoursFilled = exports.createIsoContoursFilled = void 0;\r\nvar Color_1 = __webpack_require__(/*! ./Color */ \"./src/Color.ts\");\r\nvar colorMap_1 = __webpack_require__(/*! ./colorMap */ \"./src/colorMap.ts\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\r\n/**\r\n * If min and max are not provided, there are computed from  the attribute.\r\n * If the isoValues_ array is empty, an empty object will be returned.\r\n */\r\nfunction createIsoContoursFilled(geometry, attr, isoList, _a) {\r\n    var _b = _a === void 0 ? {} : _a, _c = _b.min, min = _c === void 0 ? undefined : _c, _d = _b.max, max = _d === void 0 ? undefined : _d, _e = _b.lut, lut = _e === void 0 ? 'Rainbow' : _e, _f = _b.nbColors, nbColors = _f === void 0 ? 128 : _f;\r\n    var isoContours = new IsoContoursFilled(lut, nbColors, isoList);\r\n    return isoContours.run(geometry, attr, min, max);\r\n}\r\nexports.createIsoContoursFilled = createIsoContoursFilled;\r\nvar IsoContoursFilled = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param lut\r\n     * @param nbColors\r\n     * @param isoList The list of iso contours to generate\r\n     */\r\n    function IsoContoursFilled(lut, nbColors, isoList) {\r\n        this.attr = undefined;\r\n        this.nodes_ = undefined;\r\n        this.segment_list_ = [];\r\n        this.vmin_ = 0;\r\n        this.vmax_ = 1;\r\n        this.color_ = new Color_1.Color('#000000');\r\n        this.lutTable_ = (0, colorMap_1.createLut)('Insar', 128);\r\n        this.position_ = [];\r\n        this.index_ = [];\r\n        this.colors_ = [];\r\n        this.isoValues_ = [];\r\n        this.normals_ = [];\r\n        this.nnormals_ = undefined;\r\n        this.color_ = new Color_1.Color('#000000');\r\n        this.lutTable_ = (0, colorMap_1.createLut)(lut, nbColors);\r\n        this.lutTable_.setMin(0);\r\n        this.lutTable_.setMax(1);\r\n        this.isoValues_ = isoList;\r\n    }\r\n    Object.defineProperty(IsoContoursFilled.prototype, \"position\", {\r\n        get: function () { return this.position_; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(IsoContoursFilled.prototype, \"index\", {\r\n        get: function () { return this.index_; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(IsoContoursFilled.prototype, \"color\", {\r\n        get: function () { return this.colors_; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * If min and max are not provided, there are computed from  the attribute.\r\n     * If the isoValues_ array is empty, an empty object will be returned.\r\n     */\r\n    IsoContoursFilled.prototype.run = function (geometry, attr, min, max) {\r\n        if (min === void 0) { min = undefined; }\r\n        if (max === void 0) { max = undefined; }\r\n        this.attr = attr;\r\n        var minmax = (0, utils_1.minMax)(this.attr);\r\n        if (min !== undefined) {\r\n            this.vmin_ = min;\r\n        }\r\n        else {\r\n            this.vmin_ = minmax[0];\r\n        }\r\n        if (max !== undefined) {\r\n            this.vmax_ = max;\r\n        }\r\n        else {\r\n            this.vmax_ = minmax[1];\r\n        }\r\n        if (this.isoValues_.length === 0) {\r\n            return {\r\n                position: [],\r\n                index: [],\r\n                color: [],\r\n                normal: []\r\n            };\r\n        }\r\n        var index = geometry.getIndices();\r\n        var a = index.array;\r\n        this.nodes_ = geometry.getPositions();\r\n        this.nnormals_ = geometry.getAttribute('normal');\r\n        if (this.nnormals_ === undefined) {\r\n            geometry.computeVertexNormals();\r\n            this.nnormals_ = geometry.getAttribute('normal');\r\n        }\r\n        // The main algo\r\n        // -------------\r\n        for (var i = 0; i < a.length; i += 3) { // node indices of a triangle\r\n            this.classify(a[i], a[i + 1], a[i + 2]);\r\n        }\r\n        return {\r\n            position: this.position_,\r\n            index: this.index_,\r\n            color: this.colors_,\r\n            normal: this.normals_\r\n        };\r\n    };\r\n    IsoContoursFilled.prototype.normalizeAttr = function (v) {\r\n        return (v - this.vmin_) / (this.vmax_ - this.vmin_);\r\n    };\r\n    IsoContoursFilled.prototype.getNode = function (i) {\r\n        return this.nodes_.get(i);\r\n        // return [this.nodes_.getX(i), this.nodes_.getY(i), this.nodes_.getZ(i)]\r\n    };\r\n    IsoContoursFilled.prototype.getNormal = function (i) {\r\n        return this.nnormals_.get(i);\r\n        // return [this.nnormals_.getX(i), this.nnormals_.getY(i), this.nnormals_.getZ(i)]\r\n    };\r\n    IsoContoursFilled.prototype.getAttr = function (i) {\r\n        return this.attr[i];\r\n    };\r\n    IsoContoursFilled.prototype.classify = function (n0, n1, n2) {\r\n        var t = new TriInfo;\r\n        t.v1 = this.getAttr(n0);\r\n        t.p1 = this.getNode(n0);\r\n        t.n1 = this.getNormal(n0);\r\n        t.v2 = this.getAttr(n1);\r\n        t.p2 = this.getNode(n1);\r\n        t.n2 = this.getNormal(n1);\r\n        t.v3 = this.getAttr(n2);\r\n        t.p3 = this.getNode(n2);\r\n        t.n3 = this.getNormal(n2);\r\n        var nn1, nn2, nn3;\r\n        var vv1, vv2, vv3;\r\n        var hh1 = 0, hh2 = 0, hh3 = 0;\r\n        if (t.v1 <= t.v2 && t.v1 <= t.v3) {\r\n            vv1 = t.p1;\r\n            hh1 = t.v1;\r\n            nn1 = t.n1;\r\n            if (t.v2 <= t.v3) {\r\n                vv2 = t.p2;\r\n                vv3 = t.p3;\r\n                hh2 = t.v2;\r\n                hh3 = t.v3;\r\n                nn2 = t.n2;\r\n                nn3 = t.n3;\r\n            }\r\n            else {\r\n                vv2 = t.p3;\r\n                vv3 = t.p2;\r\n                hh2 = t.v3;\r\n                hh3 = t.v2;\r\n                nn2 = t.n3;\r\n                nn3 = t.n2;\r\n                t.reversed = true;\r\n            }\r\n        }\r\n        else if (t.v2 <= t.v1 && t.v2 <= t.v3) {\r\n            vv1 = t.p2;\r\n            hh1 = t.v2;\r\n            nn1 = t.n2;\r\n            if (t.v1 <= t.v3) {\r\n                vv2 = t.p1;\r\n                vv3 = t.p3;\r\n                hh2 = t.v1;\r\n                hh3 = t.v3;\r\n                nn2 = t.n1;\r\n                nn3 = t.n3;\r\n                t.reversed = true;\r\n            }\r\n            else {\r\n                vv2 = t.p3;\r\n                vv3 = t.p1;\r\n                hh2 = t.v3;\r\n                hh3 = t.v1;\r\n                nn2 = t.n3;\r\n                nn3 = t.n1;\r\n            }\r\n        }\r\n        else if (t.v3 <= t.v1 && t.v3 <= t.v2) {\r\n            vv1 = t.p3;\r\n            hh1 = t.v3;\r\n            nn1 = t.n3;\r\n            if (t.v1 <= t.v2) {\r\n                vv2 = t.p1;\r\n                vv3 = t.p2;\r\n                hh2 = t.v1;\r\n                hh3 = t.v2;\r\n                nn2 = t.n1;\r\n                nn3 = t.n2;\r\n            }\r\n            else {\r\n                vv2 = t.p2;\r\n                vv3 = t.p1;\r\n                hh2 = t.v2;\r\n                hh3 = t.v1;\r\n                nn2 = t.n2;\r\n                nn3 = t.n1;\r\n                t.reversed = true;\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        t.p1 = vv1;\r\n        t.p2 = vv2;\r\n        t.p3 = vv3;\r\n        t.v1 = hh1;\r\n        t.v2 = hh2;\r\n        t.v3 = hh3;\r\n        t.n1 = nn1;\r\n        t.n2 = nn2;\r\n        t.n3 = nn3;\r\n        this.createSegmentList(t); // for this current traingle\r\n        this.createPolygons(t);\r\n        n1 = n2;\r\n    };\r\n    IsoContoursFilled.prototype.createSegmentList = function (t) {\r\n        this.segment_list_ = [];\r\n        t.notIntersectedPolygonValue = this.vmin_;\r\n        for (var _i = 0, _a = this.isoValues_; _i < _a.length; _i++) {\r\n            var iso = _a[_i];\r\n            if (iso >= t.v3)\r\n                break;\r\n            if (iso > t.v1) {\r\n                this.addSegment(iso, t);\r\n            }\r\n            else {\r\n                t.notIntersectedPolygonValue = iso;\r\n            }\r\n        }\r\n    };\r\n    IsoContoursFilled.prototype.addSegment = function (iso, t) {\r\n        var segment = new IsoSegment;\r\n        segment.iso = iso;\r\n        var v1 = t.v1;\r\n        var v2 = t.v2;\r\n        var v3 = t.v3;\r\n        var p1 = t.p1;\r\n        var p2 = t.p2;\r\n        var p3 = t.p3;\r\n        if (iso < t.v2) {\r\n            var w1 = isoValue(v1, v2, iso);\r\n            var w2 = isoValue(v1, v3, iso);\r\n            segment.p1 = createPoint(p1, p2, w1);\r\n            segment.p2 = createPoint(p1, p3, w2);\r\n            segment.n1 = createPoint(t.n1, t.n2, w1);\r\n            segment.n2 = createPoint(t.n1, t.n3, w2);\r\n        }\r\n        else {\r\n            var w1 = isoValue(v2, v3, iso);\r\n            var w2 = isoValue(v1, v3, iso);\r\n            segment.p1 = createPoint(p2, p3, w1);\r\n            segment.p2 = createPoint(p1, p3, w2);\r\n            segment.n1 = createPoint(t.n2, t.n3, w1);\r\n            segment.n2 = createPoint(t.n1, t.n3, w2);\r\n        }\r\n        this.segment_list_.push(segment);\r\n    };\r\n    IsoContoursFilled.prototype.createPolygons = function (t) {\r\n        if ((t.v1 < this.vmin_ || t.v1 > this.vmax_) &&\r\n            (t.v2 < this.vmin_ || t.v2 > this.vmax_) &&\r\n            (t.v3 < this.vmin_ || t.v3 > this.vmax_)) {\r\n            return; // <-------------------------------\r\n        }\r\n        var negate = function (n) { return [-n[0], -n[1], -n[2]]; };\r\n        var bypass = false;\r\n        if (t.reversed) {\r\n            if (this.segment_list_.length === 0) {\r\n                this.addTri(t.p1, t.p3, t.p2, t.n1, t.n3, t.n2, t.notIntersectedPolygonValue);\r\n                return;\r\n            }\r\n            var seg = front(this.segment_list_);\r\n            if (seg.iso < t.v2) {\r\n                this.addTri(t.p1, seg.p2, seg.p1, t.n1, seg.n2, seg.n1, t.notIntersectedPolygonValue);\r\n            }\r\n            else {\r\n                bypass = true;\r\n                this.addQuad(t.p1, seg.p2, seg.p1, t.p2, t.n1, seg.n2, seg.n1, t.n2, t.notIntersectedPolygonValue);\r\n            }\r\n            for (var i = 1; i < this.segment_list_.length; ++i) {\r\n                var seg1 = this.segment_list_[i];\r\n                if (seg1.iso < t.v2) {\r\n                    this.addQuad(seg.p1, seg1.p1, seg1.p2, seg.p2, negate(seg.n1), negate(seg1.n1), negate(seg1.n2), negate(seg.n2), seg.iso);\r\n                }\r\n                else {\r\n                    if (bypass) {\r\n                        this.addQuad(seg.p1, seg.p2, seg1.p2, seg1.p1, seg.n1, seg.n2, seg1.n2, seg1.n1, seg.iso);\r\n                    }\r\n                    else {\r\n                        bypass = true;\r\n                        this.addPoly(t.p2, seg.p1, seg.p2, seg1.p2, seg1.p1, t.n2, seg.n1, seg.n2, seg1.n2, seg1.n1, seg.iso);\r\n                    }\r\n                }\r\n                seg = seg1;\r\n            }\r\n            seg = back(this.segment_list_);\r\n            if (bypass) {\r\n                this.addTri(seg.p1, seg.p2, t.p3, seg.n1, seg.n2, t.n3, seg.iso);\r\n            }\r\n            else {\r\n                this.addQuad(t.p2, seg.p1, seg.p2, t.p3, t.n2, seg.n1, seg.n2, t.n3, seg.iso);\r\n            }\r\n        }\r\n        //draw polygons in CW\r\n        else {\r\n            if (this.segment_list_.length === 0) {\r\n                this.addTri(t.p1, t.p2, t.p3, t.n1, t.n2, t.n3, t.notIntersectedPolygonValue);\r\n                return;\r\n            }\r\n            var seg = front(this.segment_list_);\r\n            if (seg.iso < t.v2) {\r\n                this.addTri(t.p1, seg.p1, seg.p2, t.n1, seg.n1, seg.n2, t.notIntersectedPolygonValue);\r\n            }\r\n            else {\r\n                bypass = true;\r\n                this.addQuad(t.p1, t.p2, seg.p1, seg.p2, t.n1, t.n2, seg.n1, seg.n2, t.notIntersectedPolygonValue);\r\n            }\r\n            for (var i = 1; i < this.segment_list_.length; ++i) {\r\n                var seg1 = this.segment_list_[i];\r\n                if (seg1.iso < t.v2) {\r\n                    this.addQuad(seg.p1, seg1.p1, seg1.p2, seg.p2, seg.n1, seg1.n1, seg1.n2, seg.n2, seg.iso);\r\n                }\r\n                else {\r\n                    if (bypass) {\r\n                        this.addQuad(seg.p1, seg1.p1, seg1.p2, seg.p2, seg.n1, seg1.n1, seg1.n2, seg.n2, seg.iso);\r\n                    }\r\n                    else {\r\n                        bypass = true;\r\n                        this.addPoly(t.p2, seg1.p1, seg1.p2, seg.p2, seg.p1, t.n2, seg1.n1, seg1.n2, seg.n2, seg.n1, seg.iso);\r\n                    }\r\n                }\r\n                seg = seg1;\r\n            }\r\n            seg = back(this.segment_list_);\r\n            if (bypass) {\r\n                this.addTri(seg.p1, t.p3, seg.p2, seg.n1, t.n3, seg.n2, seg.iso);\r\n            }\r\n            else {\r\n                this.addQuad(t.p2, t.p3, seg.p2, seg.p1, t.n2, t.n3, seg.n2, seg.n1, seg.iso);\r\n            }\r\n        }\r\n    };\r\n    IsoContoursFilled.prototype.addTri = function (point1, point2, point3, n1, n2, n3, iso) {\r\n        var _a, _b, _c;\r\n        if (iso < this.vmin_ || iso > this.vmax_)\r\n            return;\r\n        var c = (0, utils_1.fromValueToColor)(this.normalizeAttr(iso), {\r\n            defaultColor: this.color_,\r\n            lutTable: this.lutTable_\r\n        });\r\n        var id = this.position_.length / 3;\r\n        (_a = this.position_).push.apply(_a, __spreadArray(__spreadArray(__spreadArray([], point1, false), point2, false), point3, false));\r\n        this.index_.push(id, id + 1, id + 2);\r\n        (_b = this.colors_).push.apply(_b, __spreadArray(__spreadArray(__spreadArray([], c, false), c, false), c, false));\r\n        (_c = this.normals_).push.apply(_c, __spreadArray(__spreadArray(__spreadArray([], n1, false), n2, false), n3, false));\r\n    };\r\n    IsoContoursFilled.prototype.addQuad = function (point1, point2, point3, point4, n1, n2, n3, n4, iso) {\r\n        var _a, _b, _c;\r\n        if (iso < this.vmin_ || iso > this.vmax_)\r\n            return;\r\n        var c = (0, utils_1.fromValueToColor)(this.normalizeAttr(iso), {\r\n            defaultColor: this.color_,\r\n            lutTable: this.lutTable_\r\n        });\r\n        var id = this.position_.length / 3;\r\n        (_a = this.position_).push.apply(_a, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], point1, false), point2, false), point3, false), point4, false));\r\n        this.index_.push(id, id + 1, id + 2, id, id + 2, id + 3);\r\n        (_b = this.colors_).push.apply(_b, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], c, false), c, false), c, false), c, false));\r\n        (_c = this.normals_).push.apply(_c, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], n1, false), n2, false), n3, false), n4, false));\r\n    };\r\n    IsoContoursFilled.prototype.addPoly = function (point1, point2, point3, point4, point5, n1, n2, n3, n4, n5, iso) {\r\n        var _a, _b, _c;\r\n        if (iso < this.vmin_ || iso > this.vmax_)\r\n            return;\r\n        var c = (0, utils_1.fromValueToColor)(this.normalizeAttr(iso), {\r\n            defaultColor: this.color_,\r\n            lutTable: this.lutTable_\r\n        });\r\n        var id = this.position_.length / 3;\r\n        (_a = this.position_).push.apply(_a, __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], point1, false), point2, false), point3, false), point4, false), point5, false));\r\n        this.index_.push(id, id + 1, id + 2, id, id + 2, id + 3, id, id + 3, id + 4);\r\n        (_b = this.colors_).push.apply(_b, __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], c, false), c, false), c, false), c, false), c, false));\r\n        (_c = this.normals_).push.apply(_c, __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], n1, false), n2, false), n3, false), n4, false), n5, false));\r\n    };\r\n    return IsoContoursFilled;\r\n}());\r\nexports.IsoContoursFilled = IsoContoursFilled;\r\n// -------------------------------------------\r\nvar IsoSegment = /** @class */ (function () {\r\n    function IsoSegment() {\r\n        this.p1 = [0, 0, 0];\r\n        this.p2 = [0, 0, 0];\r\n        this.n1 = [0, 0, 1];\r\n        this.n2 = [0, 0, 1];\r\n        this.iso = 0;\r\n    }\r\n    return IsoSegment;\r\n}());\r\nvar TriInfo = /** @class */ (function () {\r\n    function TriInfo() {\r\n        this.reversed = false;\r\n        this.p1 = [0, 0, 0];\r\n        this.p2 = [0, 0, 0];\r\n        this.p3 = [0, 0, 0];\r\n        this.n1 = [1, 0, 0];\r\n        this.n2 = [1, 0, 0];\r\n        this.n3 = [1, 0, 0];\r\n        this.v1 = 0;\r\n        this.v2 = 0;\r\n        this.v3 = 0;\r\n        this.notIntersectedPolygonValue = 0;\r\n    }\r\n    return TriInfo;\r\n}());\r\nvar front = function (container) { return container[0]; };\r\nvar back = function (container) { return container[container.length - 1]; };\r\nfunction createPoint(p1, p2, w) {\r\n    var W = 1. - w;\r\n    return [\r\n        w * p1[0] + W * p2[0],\r\n        w * p1[1] + W * p2[1],\r\n        w * p1[2] + W * p2[2]\r\n    ];\r\n}\r\nfunction isoValue(v1, v2, iso) {\r\n    return 1. - (Math.abs(iso - v1) / Math.abs(v2 - v1));\r\n}\r\n\n\n//# sourceURL=webpack://keplerlit/./src/IsoContoursFilled.ts?\n}");

/***/ }),

/***/ "./src/IsoContoursLines.ts":
/*!*********************************!*\
  !*** ./src/IsoContoursLines.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.createIsoContourLines = void 0;\r\nvar Color_1 = __webpack_require__(/*! ./Color */ \"./src/Color.ts\");\r\nvar colorMap_1 = __webpack_require__(/*! ./colorMap */ \"./src/colorMap.ts\");\r\nvar MarchingTriangle_1 = __webpack_require__(/*! ./MarchingTriangle */ \"./src/MarchingTriangle.ts\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\r\nfunction createIsoContourLines(mesh, attribute, isoList, defaultColor, lut) {\r\n    var _this = this;\r\n    if (mesh === undefined) {\r\n        throw new Error('mesh is undefined');\r\n    }\r\n    if (mesh.getPositions() === undefined) {\r\n        throw new Error('mesh.positions is undefined');\r\n    }\r\n    if (mesh.getIndices() === undefined) {\r\n        throw new Error('mesh.indices is undefined');\r\n    }\r\n    if (attribute === undefined) {\r\n        throw new Error('attribute is undefined');\r\n    }\r\n    var mm = (0, utils_1.minMax)(attribute);\r\n    var vmin = mm[0];\r\n    var vmax = mm[1];\r\n    var lutTable = undefined;\r\n    if (lut === undefined || lut === null) {\r\n        lutTable = (0, colorMap_1.createLut)(lut, 128);\r\n        lutTable.setMin(vmin);\r\n        lutTable.setMax(vmax);\r\n    }\r\n    var dColor = new Color_1.Color(defaultColor);\r\n    var isoValues = isoList;\r\n    var algo = new MarchingTriangle_1.MarchingTriangles();\r\n    algo.setup(mesh.getIndices(), [vmin, vmax]);\r\n    var vertices = mesh.getPositions();\r\n    var positions = [];\r\n    var colors = [];\r\n    var normalizeAttr = function (v) { return (v - _this.vmin_) / (_this.vmax_ - _this.vmin_); };\r\n    for (var i = 0; i < isoValues.length; ++i) {\r\n        var result = algo.isolines(attribute, isoValues[i]);\r\n        var c = (0, utils_1.fromValueToColor)(normalizeAttr(isoValues[i]), {\r\n            min: vmin,\r\n            max: vmax,\r\n            defaultColor: dColor,\r\n            lutTable: lutTable\r\n        });\r\n        colors.push.apply(colors, c);\r\n        for (var k = 0; k < result[0].length; ++k) {\r\n            for (var l = 0; l < result[0][k].length - 2; l += 2) {\r\n                var i1 = result[0][k][l];\r\n                var i2 = result[0][k][l + 1];\r\n                var c_1 = result[1][k][l / 2];\r\n                var v1 = vertices.get(i1);\r\n                var v2 = vertices.get(i2);\r\n                var v1x = v1[0];\r\n                var v1y = v1[1];\r\n                var v1z = v1[2];\r\n                var v2x = v2[0];\r\n                var v2y = v2[1];\r\n                var v2z = v2[2];\r\n                positions.push(v1x + c_1 * (v2x - v1x), v1y + c_1 * (v2y - v1y), v1z + c_1 * (v2z - v1z));\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        positions: positions,\r\n        color: colors\r\n    };\r\n}\r\nexports.createIsoContourLines = createIsoContourLines;\r\n\n\n//# sourceURL=webpack://keplerlit/./src/IsoContoursLines.ts?\n}");

/***/ }),

/***/ "./src/MarchingTriangle.ts":
/*!*********************************!*\
  !*** ./src/MarchingTriangle.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.MarchingTriangles = void 0;\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\r\nvar MarchingTriangles = /** @class */ (function () {\r\n    function MarchingTriangles() {\r\n        this.topo_ = [];\r\n        this.lock_ = false;\r\n        this.maxVertexIndex_ = -1;\r\n        this._bounds = [];\r\n    }\r\n    // topo of type BufferAttribute (with item count corresponding to 1 id)\r\n    MarchingTriangles.prototype.setup = function (topo, bounds) {\r\n        this.lock_ = false;\r\n        this.maxVertexIndex_ = -1;\r\n        this._bounds = bounds;\r\n        this.topo_ = [];\r\n        for (var l = 0; l < topo.array.length; l += 3) {\r\n            var i = topo.array[l];\r\n            var j = topo.array[l + 1];\r\n            var k = topo.array[l + 2];\r\n            this.topo_.push({ i: i, j: j, k: k });\r\n            if (i === j || i === k || j === k) {\r\n                throw new Error(\"Error in topology while setting up iso-contouring in 'MarchingTriangles.' At index \".concat(l, \", got 3 indices (\").concat(i, \", \").concat(j, \", \").concat(k, \")\"));\r\n            }\r\n            this.maxVertexIndex_ = Math.max(this.maxVertexIndex_, i, j, k);\r\n        }\r\n        // topo.forEach((value: number[], index: number) => {\r\n        //     let i = value[0]\r\n        //     let j = value[1]\r\n        //     let k = value[2]\r\n        //     this.topo_.push({ i, j, k })\r\n        //     if (i === j || i === k || j === k) {\r\n        //         throw new Error(`Error in topology while setting up iso-contouring in 'MarchingTriangles.' At index ${index}, got 3 indices (${i}, ${j}, ${k})`)\r\n        //     }\r\n        //     this.maxVertexIndex_ = Math.max(this.maxVertexIndex_, i, j, k)\r\n        // })\r\n        this.lock_ = true;\r\n        return true;\r\n    };\r\n    /**\r\n     * Return array of size 2:\r\n     *\r\n     * 1) result[0] represents the connected isoline edges\r\n     *\r\n     * 2) result[1] represents the connected isoline values\r\n     */\r\n    MarchingTriangles.prototype.isolines = function (prop, isovalue) {\r\n        var result = [[]];\r\n        if (this.lock_ === false) {\r\n            return result;\r\n        }\r\n        if (prop.length < 0) {\r\n            return result;\r\n        }\r\n        if (this._bounds === undefined) {\r\n            this._bounds = (0, utils_1.minMax)(prop);\r\n        }\r\n        // Store the triangles cross by the iso-surface and for\r\n        // each triangle i stored its value [1,6]\r\n        var tri2code = new Map();\r\n        var cut_edges = [];\r\n        var triangle = [0, 0, 0];\r\n        var connectiviy = new Map(new Map());\r\n        for (var i = 0; i < this.topo_.length; ++i) {\r\n            triangle[0] = this.topo_[i].i;\r\n            triangle[1] = this.topo_[i].j;\r\n            triangle[2] = this.topo_[i].k;\r\n            var t1 = void 0, t2 = void 0, t3 = void 0;\r\n            var p0 = prop[triangle[0]];\r\n            var p1 = prop[triangle[1]];\r\n            var p2 = prop[triangle[2]];\r\n            if (ok(p0, p1, p2, this._bounds[0], this._bounds[1]) === false) {\r\n                continue;\r\n            }\r\n            if ((p0 >= isovalue)) {\r\n                t1 = 1;\r\n            }\r\n            else {\r\n                t1 = 0;\r\n            }\r\n            if ((p1 >= isovalue)) {\r\n                t2 = 1;\r\n            }\r\n            else {\r\n                t2 = 0;\r\n            }\r\n            if ((p2 >= isovalue)) {\r\n                t3 = 1;\r\n            }\r\n            else {\r\n                t3 = 0;\r\n            }\r\n            var tri_code = lookupTable1[t1][t2][t3];\r\n            // means that this triangle is cut by the isoline\r\n            if (tri_code > 0 && tri_code < 7) {\r\n                tri2code.set(i, tri_code);\r\n                cut_edges[0] = lookupTable0[tri_code][0];\r\n                cut_edges[1] = lookupTable0[tri_code][1];\r\n                for (var e = 0; e < 2; ++e) {\r\n                    var v0 = cut_edges[e];\r\n                    var v1 = (v0 + 1) % 3;\r\n                    v0 = triangle[v0];\r\n                    v1 = triangle[v1];\r\n                    var vmin = Math.min(v0, v1);\r\n                    var vmax = Math.max(v0, v1);\r\n                    if (!(vmin in connectiviy)) {\r\n                        var vmax_2_triangles = new Map();\r\n                        vmax_2_triangles.set(vmax, [i]);\r\n                        connectiviy.set(vmin, vmax_2_triangles);\r\n                    }\r\n                    else {\r\n                        connectiviy.get(vmin).get(vmax).push(i);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Extraction...\r\n        do {\r\n            if (tri2code.size <= 0)\r\n                break;\r\n            var isoline = [];\r\n            var values = [];\r\n            var start = tri2code.keys();\r\n            var first_tri = start.next().value;\r\n            var code = tri2code.get(first_tri);\r\n            tri2code.delete(tri2code.keys().next().value);\r\n            if (code < 1 || code > 6) {\r\n                continue;\r\n            }\r\n            triangle[0] = this.topo_[first_tri].i;\r\n            triangle[1] = this.topo_[first_tri].j;\r\n            triangle[2] = this.topo_[first_tri].k;\r\n            cut_edges[0] = lookupTable0[code][0];\r\n            cut_edges[1] = lookupTable0[code][1];\r\n            var first_edge = [];\r\n            var next_edge = [];\r\n            for (var e = 0; e < 2; ++e) {\r\n                var v0 = cut_edges[e];\r\n                var v1 = (v0 + 1) % 3;\r\n                v0 = triangle[v0];\r\n                v1 = triangle[v1];\r\n                isoline.push(v0);\r\n                isoline.push(v1);\r\n                values.push((isovalue - prop[v0]) / (prop[v1] - prop[v0]));\r\n                var vmin = Math.min(v0, v1);\r\n                var vmax = Math.max(v0, v1);\r\n                if (e === 0) {\r\n                    first_edge[0] = vmin;\r\n                    first_edge[1] = vmax;\r\n                }\r\n                else {\r\n                    next_edge[0] = vmin;\r\n                    next_edge[1] = vmax;\r\n                }\r\n            }\r\n            var first_e = 0;\r\n            var nb_loop = 0;\r\n            do {\r\n                var current_tri = first_tri;\r\n                do {\r\n                    var adj_trgls = [connectiviy.get(next_edge[0]).get(next_edge[1])];\r\n                    if (adj_trgls.length === 1) {\r\n                        break; // border\r\n                    }\r\n                    current_tri = adj_trgls[0] + adj_trgls[1] - current_tri;\r\n                    var iter = tri2code.get(current_tri);\r\n                    if (!(iter in tri2code)) {\r\n                        break;\r\n                    }\r\n                    code = iter.second;\r\n                    tri2code.delete(iter);\r\n                    // let f = this.topo_[current_tri] ;\r\n                    triangle[0] = this.topo_[current_tri].i;\r\n                    triangle[1] = this.topo_[current_tri].j;\r\n                    triangle[2] = this.topo_[current_tri].k;\r\n                    cut_edges[0] = lookupTable0[code][0];\r\n                    cut_edges[1] = lookupTable0[code][1];\r\n                    for (var e = 0; e < 2; ++e) {\r\n                        var v0 = cut_edges[e];\r\n                        var v1 = (v0 + 1) % 3;\r\n                        v0 = triangle[v0];\r\n                        v1 = triangle[v1];\r\n                        var vmin = Math.min(v0, v1);\r\n                        var vmax = Math.max(v0, v1);\r\n                        if (vmin !== next_edge[0] || vmax !== next_edge[1]) {\r\n                            isoline.push(v0);\r\n                            isoline.push(v1);\r\n                            values.push((isovalue - prop[v0]) / (prop[v1] - prop[v0]));\r\n                            next_edge[0] = vmin;\r\n                            next_edge[1] = vmax;\r\n                            break;\r\n                        }\r\n                    }\r\n                } while (true);\r\n                if (next_edge[0] === first_edge[0] && next_edge[1] === first_edge[1]) {\r\n                    // Closed line\r\n                    isoline.push(isoline[0]);\r\n                    isoline.push(isoline[1]);\r\n                    values.push(values[0]);\r\n                    first_e = values.length;\r\n                    break;\r\n                }\r\n                else if (nb_loop === 0) {\r\n                    next_edge[0] = first_edge[0];\r\n                    next_edge[1] = first_edge[1];\r\n                    first_e = values.length;\r\n                }\r\n                ++nb_loop;\r\n            } while (nb_loop < 2);\r\n            if (first_e === values.length) {\r\n                result[0].push(isoline);\r\n                if (result[1] === undefined) {\r\n                    result[1] = [values];\r\n                }\r\n                else {\r\n                    result[1].push(values);\r\n                }\r\n            }\r\n            else {\r\n                var connected_isoline_edges = [];\r\n                var connected_isoline_values = [];\r\n                for (var j = isoline.length - 1; j >= 2 * first_e; --j) {\r\n                    connected_isoline_edges.push(isoline[j]);\r\n                }\r\n                for (var j = values.length - 1; j >= first_e; --j) {\r\n                    connected_isoline_values.push(1.0 - values[j]);\r\n                }\r\n                for (var j = 0; j < 2 * first_e; ++j) {\r\n                    connected_isoline_edges.push(isoline[j]);\r\n                }\r\n                for (var j = 0; j < first_e; ++j) {\r\n                    connected_isoline_values.push(values[j]);\r\n                }\r\n                result[0].push(connected_isoline_edges);\r\n                result[1].push(connected_isoline_values);\r\n            }\r\n        } while (true);\r\n        return result;\r\n    };\r\n    return MarchingTriangles;\r\n}());\r\nexports.MarchingTriangles = MarchingTriangles;\r\nfunction ok(p0, p1, p2, min, max) {\r\n    function _in(p, min, max) {\r\n        return p >= min && p <= max;\r\n    }\r\n    return _in(p0, min, max) && _in(p1, min, max) && _in(p2, min, max);\r\n}\r\nvar lookupTable0 = [[-1, -1], [1, 2], [0, 1], [2, 0], [2, 0], [0, 1], [1, 2], [-1, -1]];\r\nvar lookupTable1 = [[[0, 1], [2, 3]], [[4, 5], [6, 7]]];\r\n\n\n//# sourceURL=webpack://keplerlit/./src/MarchingTriangle.ts?\n}");

/***/ }),

/***/ "./src/attributes.ts":
/*!***************************!*\
  !*** ./src/attributes.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports) {

eval("{\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.Float32BufferAttribute = exports.BufferGeometry = exports.BufferAttribute = void 0;\r\n/**\r\n * BufferAttribute class for handling typed arrays in WebGL.\r\n *\r\n * We rewrite it in order to avoid using the THREE.js library if necessary.\r\n *\r\n * @param array - The typed array (Float32Array, Uint16Array, or Uint32Array)\r\n * @param itemSize - Number of components per item (e.g., 3 for vec3)\r\n * @param normalized - Whether the attribute is normalized (default: false)\r\n * @param usage - WebGL usage hint (default: STATIC_DRAW)\r\n * @param updateRange - Range of items to update (default: entire array)\r\n * @param version - Version number for tracking changes (default: 0)\r\n * @param needsUpdate - Whether the attribute needs to be updated (default: false)\r\n *\r\n * Example usage:\r\n * @example\r\n * // Create position attribute (3 components per vertex)\r\n * const positions = new Float32BufferAttribute([\r\n *   0, 0, 0,    // vertex 0\r\n *   1, 0, 0,    // vertex 1\r\n *   0, 1, 0     // vertex 2\r\n * ], 3);\r\n *\r\n * // Set vertex at index 1\r\n * positions.set(1, [2, 0, 0]);\r\n *\r\n * // Get vertex at index 0\r\n * const vertex0 = positions.get(0); // [0, 0, 0]\r\n *\r\n * // Set individual component\r\n * positions.setComponent(2, 2, 1); // Set z-component of vertex 2 to 1\r\n *\r\n * // Create color attribute (4 components: RGBA)\r\n * const colors = new Float32BufferAttribute([\r\n *   1, 0, 0, 1,    // red\r\n *   0, 1, 0, 1,    // green\r\n *   0, 0, 1, 1     // blue\r\n * ], 4);\r\n *\r\n * // Get color of vertex 1\r\n * const color1 = colors.get(1); // [0, 1, 0, 1]\r\n *\r\n * // Create UV coordinates (2 components per vertex)\r\n * const uvs = new Float32BufferAttribute([\r\n *   0, 0,    // vertex 0\r\n *   1, 0,    // vertex 1\r\n *   0, 1     // vertex 2\r\n * ], 2);\r\n *\r\n * // Copy vertex 0 UV to vertex 2\r\n * uvs.copyAt(2, uvs, 0);\r\n *\r\n * // Apply transformation to all positions\r\n * positions.forEach((values, index) => {\r\n *   return [values[0] * 2, values[1] * 2, values[2] * 2]; // Scale by 2\r\n * });\r\n */\r\nvar BufferAttribute = /** @class */ (function () {\r\n    function BufferAttribute(array, itemSize, normalized) {\r\n        if (normalized === void 0) { normalized = false; }\r\n        this.array = array;\r\n        this.itemSize = itemSize;\r\n        this.count = array.length / itemSize;\r\n        this.normalized = normalized;\r\n        this.usage = 35044; // WebGL STATIC_DRAW\r\n        this.updateRange = { offset: 0, count: -1 };\r\n        this.version = 0;\r\n        this.needsUpdate = false;\r\n    }\r\n    /**\r\n     * Set values at a specific index\r\n     * @param index - The index of the item (not the array index)\r\n     * @param values - Array of values, must be of length itemSize\r\n     */\r\n    BufferAttribute.prototype.set = function (index, values) {\r\n        if (values.length !== this.itemSize) {\r\n            throw new Error(\"Expected \".concat(this.itemSize, \" values, got \").concat(values.length));\r\n        }\r\n        if (index < 0 || index >= this.count) {\r\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\r\n        }\r\n        var startIndex = index * this.itemSize;\r\n        for (var i = 0; i < this.itemSize; i++) {\r\n            this.array[startIndex + i] = values[i];\r\n        }\r\n        this.needsUpdate = true;\r\n        return this;\r\n    };\r\n    /**\r\n     * Get values at a specific index\r\n     * @param index - The index of the item (not the array index)\r\n     * @returns Array of values of length itemSize\r\n     */\r\n    BufferAttribute.prototype.get = function (index) {\r\n        if (index < 0 || index >= this.count) {\r\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\r\n        }\r\n        var startIndex = index * this.itemSize;\r\n        var result = [];\r\n        for (var i = 0; i < this.itemSize; i++) {\r\n            result.push(this.array[startIndex + i]);\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * @brief Get the x component of an item at a specific index.\r\n     * Similar to get(index)[0], but optimized for performance.\r\n     */\r\n    BufferAttribute.prototype.getX = function (index) {\r\n        if (index < 0 || index >= this.count) {\r\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\r\n        }\r\n        return this.array[index * this.itemSize];\r\n    };\r\n    /**\r\n     * @brief Get the y component of an item at a specific index.\r\n     * * Similar to get(index)[1], but optimized for performance.\r\n     */\r\n    BufferAttribute.prototype.getY = function (index) {\r\n        if (this.itemSize < 2) {\r\n            throw new Error(\"Item size is \".concat(this.itemSize, \", cannot get Y component\"));\r\n        }\r\n        return this.array[index * this.itemSize + 1];\r\n    };\r\n    /**\r\n     * @brief Get the z component of an item at a specific index.\r\n     * * Similar to get(index)[2], but optimized for performance.\r\n     */\r\n    BufferAttribute.prototype.getZ = function (index) {\r\n        if (this.itemSize < 3) {\r\n            throw new Error(\"Item size is \".concat(this.itemSize, \", cannot get Z component\"));\r\n        }\r\n        return this.array[index * this.itemSize + 2];\r\n    };\r\n    /**\r\n     * Set a single component value at a specific index and component\r\n     * @param index - The index of the item\r\n     * @param component - The component index (0 to itemSize-1)\r\n     * @param value - The value to set\r\n     */\r\n    BufferAttribute.prototype.setComponent = function (index, component, value) {\r\n        if (index < 0 || index >= this.count) {\r\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\r\n        }\r\n        if (component < 0 || component >= this.itemSize) {\r\n            throw new Error(\"Component \".concat(component, \" out of range [0, \").concat(this.itemSize - 1, \"]\"));\r\n        }\r\n        this.array[index * this.itemSize + component] = value;\r\n        this.needsUpdate = true;\r\n        return this;\r\n    };\r\n    /**\r\n     * Get a single component value at a specific index and component\r\n     * @param index - The index of the item\r\n     * @param component - The component index (0 to itemSize-1)\r\n     * @returns The component value\r\n     */\r\n    BufferAttribute.prototype.getComponent = function (index, component) {\r\n        if (index < 0 || index >= this.count) {\r\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\r\n        }\r\n        if (component < 0 || component >= this.itemSize) {\r\n            throw new Error(\"Component \".concat(component, \" out of range [0, \").concat(this.itemSize - 1, \"]\"));\r\n        }\r\n        return this.array[index * this.itemSize + component];\r\n    };\r\n    /**\r\n     * Copy data from another BufferAttribute\r\n     * @param source - The source BufferAttribute\r\n     */\r\n    BufferAttribute.prototype.copy = function (source) {\r\n        this.array = source.array.slice();\r\n        this.itemSize = source.itemSize;\r\n        this.count = source.count;\r\n        this.normalized = source.normalized;\r\n        this.usage = source.usage;\r\n        this.updateRange = __assign({}, source.updateRange);\r\n        this.version = source.version;\r\n        this.needsUpdate = source.needsUpdate;\r\n        return this;\r\n    };\r\n    /**\r\n     * Copy an item from another BufferAttribute at different indices\r\n     * @param index1 - Target index in this attribute\r\n     * @param attribute - Source BufferAttribute\r\n     * @param index2 - Source index in the source attribute\r\n     */\r\n    BufferAttribute.prototype.copyAt = function (index1, attribute, index2) {\r\n        if (this.itemSize !== attribute.itemSize) {\r\n            throw new Error(\"ItemSize mismatch: \".concat(this.itemSize, \" vs \").concat(attribute.itemSize));\r\n        }\r\n        var values = attribute.get(index2);\r\n        this.set(index1, values);\r\n        return this;\r\n    };\r\n    /**\r\n     * Clone this BufferAttribute\r\n     * @returns A new BufferAttribute with the same data\r\n     */\r\n    BufferAttribute.prototype.clone = function () {\r\n        var TypedArrayConstructor = this.array.constructor;\r\n        var clonedArray = new TypedArrayConstructor(this.array);\r\n        return new BufferAttribute(clonedArray, this.itemSize, this.normalized);\r\n    };\r\n    /**\r\n     * Set the usage hint for WebGL\r\n     * @param usage - WebGL usage constant\r\n     */\r\n    BufferAttribute.prototype.setUsage = function (usage) {\r\n        this.usage = usage;\r\n        return this;\r\n    };\r\n    /**\r\n     * Get the size in bytes of the array\r\n     */\r\n    BufferAttribute.prototype.getByteLength = function () {\r\n        return this.array.byteLength;\r\n    };\r\n    /**\r\n     * Apply a function to each item in the attribute\r\n     * @param callback - Function to apply, receives (values, index) and should return new values\r\n     */\r\n    BufferAttribute.prototype.forEach = function (callback) {\r\n        for (var i = 0; i < this.count; i++) {\r\n            var currentValues = this.get(i);\r\n            callback(currentValues, i);\r\n        }\r\n        return this;\r\n    };\r\n    return BufferAttribute;\r\n}());\r\nexports.BufferAttribute = BufferAttribute;\r\n/**\r\n * BufferGeometry class for handling multiple BufferAttributes + one for the geometry and one for the indices\r\n */\r\nvar BufferGeometry = /** @class */ (function () {\r\n    function BufferGeometry(positions, indices) {\r\n        this.attributes = {};\r\n        this.positions = null;\r\n        this.indices = null;\r\n        if (positions) {\r\n            this.positions = positions;\r\n        }\r\n        if (indices) {\r\n            this.indices = indices;\r\n        }\r\n    }\r\n    BufferGeometry.prototype.setPositions = function (positions) {\r\n        this.positions = positions;\r\n        return this;\r\n    };\r\n    BufferGeometry.prototype.getPositions = function () {\r\n        return this.positions;\r\n    };\r\n    BufferGeometry.prototype.setIndices = function (indices) {\r\n        this.indices = indices;\r\n        return this;\r\n    };\r\n    BufferGeometry.prototype.getIndices = function () {\r\n        return this.indices;\r\n    };\r\n    BufferGeometry.prototype.setAttribute = function (name, attribute) {\r\n        this.attributes[name] = attribute;\r\n        return this;\r\n    };\r\n    BufferGeometry.prototype.getAttribute = function (name) {\r\n        return this.attributes[name];\r\n    };\r\n    /**\r\n     * Compute smooth vertex normals for the geometry\r\n     * This method calculates normals by averaging face normals of adjacent triangles\r\n     */\r\n    BufferGeometry.prototype.computeVertexNormals = function () {\r\n        if (!this.positions) {\r\n            console.warn('Cannot compute vertex normals: no position attribute found');\r\n            return this;\r\n        }\r\n        var positionAttribute = this.positions;\r\n        var vertexCount = positionAttribute.count;\r\n        // Initialize normals array with zeros\r\n        var normals = new Float32Array(vertexCount * 3);\r\n        // Create or get the normal attribute\r\n        var normalAttribute = this.getAttribute('normal');\r\n        if (!normalAttribute) {\r\n            normalAttribute = new Float32BufferAttribute(normals, 3);\r\n            this.setAttribute('normal', normalAttribute);\r\n        }\r\n        else {\r\n            // Reset existing normals to zero\r\n            normals.fill(0);\r\n            normalAttribute.array = normals;\r\n        }\r\n        // Helper vectors for calculations\r\n        var v0 = [0, 0, 0];\r\n        var v1 = [0, 0, 0];\r\n        var v2 = [0, 0, 0];\r\n        var edge1 = [0, 0, 0];\r\n        var edge2 = [0, 0, 0];\r\n        var faceNormal = [0, 0, 0];\r\n        // Function to calculate cross product\r\n        var cross = function (a, b, result) {\r\n            result[0] = a[1] * b[2] - a[2] * b[1];\r\n            result[1] = a[2] * b[0] - a[0] * b[2];\r\n            result[2] = a[0] * b[1] - a[1] * b[0];\r\n        };\r\n        // Function to subtract vectors\r\n        var subtract = function (a, b, result) {\r\n            result[0] = a[0] - b[0];\r\n            result[1] = a[1] - b[1];\r\n            result[2] = a[2] - b[2];\r\n        };\r\n        // Function to add vectors\r\n        var add = function (a, b) {\r\n            a[0] += b[0];\r\n            a[1] += b[1];\r\n            a[2] += b[2];\r\n        };\r\n        if (this.indices) {\r\n            // Indexed geometry - iterate through triangles using indices\r\n            var indexArray = this.indices.array;\r\n            var triangleCount = indexArray.length / 3;\r\n            for (var i = 0; i < triangleCount; i++) {\r\n                var i0 = indexArray[i * 3];\r\n                var i1 = indexArray[i * 3 + 1];\r\n                var i2 = indexArray[i * 3 + 2];\r\n                // Get vertices\r\n                v0[0] = positionAttribute.getComponent(i0, 0);\r\n                v0[1] = positionAttribute.getComponent(i0, 1);\r\n                v0[2] = positionAttribute.getComponent(i0, 2);\r\n                v1[0] = positionAttribute.getComponent(i1, 0);\r\n                v1[1] = positionAttribute.getComponent(i1, 1);\r\n                v1[2] = positionAttribute.getComponent(i1, 2);\r\n                v2[0] = positionAttribute.getComponent(i2, 0);\r\n                v2[1] = positionAttribute.getComponent(i2, 1);\r\n                v2[2] = positionAttribute.getComponent(i2, 2);\r\n                // Calculate edges\r\n                subtract(v1, v0, edge1);\r\n                subtract(v2, v0, edge2);\r\n                // Calculate face normal (cross product)\r\n                cross(edge1, edge2, faceNormal);\r\n                // Add face normal to each vertex normal\r\n                var n0 = [normals[i0 * 3], normals[i0 * 3 + 1], normals[i0 * 3 + 2]];\r\n                var n1 = [normals[i1 * 3], normals[i1 * 3 + 1], normals[i1 * 3 + 2]];\r\n                var n2 = [normals[i2 * 3], normals[i2 * 3 + 1], normals[i2 * 3 + 2]];\r\n                add(n0, faceNormal);\r\n                add(n1, faceNormal);\r\n                add(n2, faceNormal);\r\n                // Store back in array\r\n                normals[i0 * 3] = n0[0];\r\n                normals[i0 * 3 + 1] = n0[1];\r\n                normals[i0 * 3 + 2] = n0[2];\r\n                normals[i1 * 3] = n1[0];\r\n                normals[i1 * 3 + 1] = n1[1];\r\n                normals[i1 * 3 + 2] = n1[2];\r\n                normals[i2 * 3] = n2[0];\r\n                normals[i2 * 3 + 1] = n2[1];\r\n                normals[i2 * 3 + 2] = n2[2];\r\n            }\r\n        }\r\n        else {\r\n            // Non-indexed geometry - vertices are stored sequentially in triangles\r\n            var triangleCount = vertexCount / 3;\r\n            for (var i = 0; i < triangleCount; i++) {\r\n                var i0 = i * 3;\r\n                var i1 = i * 3 + 1;\r\n                var i2 = i * 3 + 2;\r\n                // Get vertices\r\n                v0[0] = positionAttribute.getComponent(i0, 0);\r\n                v0[1] = positionAttribute.getComponent(i0, 1);\r\n                v0[2] = positionAttribute.getComponent(i0, 2);\r\n                v1[0] = positionAttribute.getComponent(i1, 0);\r\n                v1[1] = positionAttribute.getComponent(i1, 1);\r\n                v1[2] = positionAttribute.getComponent(i1, 2);\r\n                v2[0] = positionAttribute.getComponent(i2, 0);\r\n                v2[1] = positionAttribute.getComponent(i2, 1);\r\n                v2[2] = positionAttribute.getComponent(i2, 2);\r\n                // Calculate edges\r\n                subtract(v1, v0, edge1);\r\n                subtract(v2, v0, edge2);\r\n                // Calculate face normal (cross product)\r\n                cross(edge1, edge2, faceNormal);\r\n                // For non-indexed geometry, each vertex belongs to only one triangle\r\n                // so we can directly assign the face normal\r\n                normals[i0 * 3] = faceNormal[0];\r\n                normals[i0 * 3 + 1] = faceNormal[1];\r\n                normals[i0 * 3 + 2] = faceNormal[2];\r\n                normals[i1 * 3] = faceNormal[0];\r\n                normals[i1 * 3 + 1] = faceNormal[1];\r\n                normals[i1 * 3 + 2] = faceNormal[2];\r\n                normals[i2 * 3] = faceNormal[0];\r\n                normals[i2 * 3 + 1] = faceNormal[1];\r\n                normals[i2 * 3 + 2] = faceNormal[2];\r\n            }\r\n        }\r\n        // Normalize all normal vectors\r\n        for (var i = 0; i < vertexCount; i++) {\r\n            var x = normals[i * 3];\r\n            var y = normals[i * 3 + 1];\r\n            var z = normals[i * 3 + 2];\r\n            var length_1 = Math.sqrt(x * x + y * y + z * z);\r\n            if (length_1 > 0) {\r\n                normals[i * 3] = x / length_1;\r\n                normals[i * 3 + 1] = y / length_1;\r\n                normals[i * 3 + 2] = z / length_1;\r\n            }\r\n            else {\r\n                // Handle degenerate case (zero-length normal)\r\n                normals[i * 3] = 0;\r\n                normals[i * 3 + 1] = 1;\r\n                normals[i * 3 + 2] = 0;\r\n            }\r\n        }\r\n        // Update the normal attribute\r\n        normalAttribute.needsUpdate = true;\r\n        return this;\r\n    };\r\n    return BufferGeometry;\r\n}());\r\nexports.BufferGeometry = BufferGeometry;\r\n// Convenience constructors for different types\r\n/**\r\n * Float32BufferAttribute class for handling Float32Array\r\n * @param array - The typed array (Float32Array or number[])\r\n * @param itemSize - Number of components per item (e.g., 3 for vec3)\r\n * @param normalized - Whether the attribute is normalized (default: false)\r\n */\r\nvar Float32BufferAttribute = /** @class */ (function (_super) {\r\n    __extends(Float32BufferAttribute, _super);\r\n    function Float32BufferAttribute(array, itemSize, normalized) {\r\n        if (normalized === void 0) { normalized = false; }\r\n        var typedArray = array instanceof Float32Array ? array : new Float32Array(array);\r\n        return _super.call(this, typedArray, itemSize, normalized) || this;\r\n    }\r\n    return Float32BufferAttribute;\r\n}(BufferAttribute));\r\nexports.Float32BufferAttribute = Float32BufferAttribute;\r\n/**\r\n * Uint16BufferAttribute class for handling Uint16Array\r\n * @param array - The typed array (Uint16Array or number[])\r\n * @param itemSize - Number of components per item (e.g., 3 for vec3)\r\n * @param normalized - Whether the attribute is normalized (default: false)\r\n */\r\nvar Uint16BufferAttribute = /** @class */ (function (_super) {\r\n    __extends(Uint16BufferAttribute, _super);\r\n    function Uint16BufferAttribute(array, itemSize, normalized) {\r\n        if (normalized === void 0) { normalized = false; }\r\n        var typedArray = array instanceof Uint16Array ? array : new Uint16Array(array);\r\n        return _super.call(this, typedArray, itemSize, normalized) || this;\r\n    }\r\n    return Uint16BufferAttribute;\r\n}(BufferAttribute));\r\nexports.Uint16BufferAttribute = Uint16BufferAttribute;\r\n/**\r\n * Uint32BufferAttribute class for handling Uint32Array\r\n * @param array - The typed array (Uint32Array or number[])\r\n * @param itemSize - Number of components per item (e.g., 3 for vec3)\r\n * @param normalized - Whether the attribute is normalized (default: false)\r\n */\r\nvar Uint32BufferAttribute = /** @class */ (function (_super) {\r\n    __extends(Uint32BufferAttribute, _super);\r\n    function Uint32BufferAttribute(array, itemSize, normalized) {\r\n        if (normalized === void 0) { normalized = false; }\r\n        var typedArray = array instanceof Uint32Array ? array : new Uint32Array(array);\r\n        return _super.call(this, typedArray, itemSize, normalized) || this;\r\n    }\r\n    return Uint32BufferAttribute;\r\n}(BufferAttribute));\r\nexports.Uint32BufferAttribute = Uint32BufferAttribute;\r\n\n\n//# sourceURL=webpack://keplerlit/./src/attributes.ts?\n}");

/***/ }),

/***/ "./src/colorMap.ts":
/*!*************************!*\
  !*** ./src/colorMap.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\r\n/**\r\n * @author daron1337 / http://daron1337.github.io/\r\n * @author fmaerten  / https://github.com/xaliphostes\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ColorMap = exports.addColorMap = exports.colorMapNames = exports.createLut = void 0;\r\nvar Color_1 = __webpack_require__(/*! ./Color */ \"./src/Color.ts\");\r\nfunction createLut(name, numberofcolors, duplicate) {\r\n    if (duplicate === void 0) { duplicate = 1; }\r\n    var map = ColorMapKeywords[name] || ColorMapKeywords.Rainbow;\r\n    var newMap = [];\r\n    var start = 0;\r\n    for (var i = 0; i < duplicate; ++i) {\r\n        map.forEach(function (m) {\r\n            // newMap.push([Color.toHexString(start + m[0] / duplicate), m[1]])\r\n            newMap.push([start + m[0] / duplicate, m[1]]);\r\n        });\r\n        start += 1 / duplicate;\r\n    }\r\n    return new ColorMap(newMap, numberofcolors);\r\n}\r\nexports.createLut = createLut;\r\nfunction colorMapNames() {\r\n    var names = [];\r\n    for (var _i = 0, _a = Object.entries(ColorMapKeywords); _i < _a.length; _i++) {\r\n        var _b = _a[_i], key = _b[0], value = _b[1];\r\n        names.push(key);\r\n    }\r\n    return names;\r\n}\r\nexports.colorMapNames = colorMapNames;\r\nfunction addColorMap(colormapName, arrayOfColors) {\r\n    ColorMapKeywords[colormapName] = arrayOfColors;\r\n}\r\nexports.addColorMap = addColorMap;\r\n/**\r\n * @category Color Lookup Table\r\n */\r\nvar ColorMap = /** @class */ (function () {\r\n    function ColorMap(colormap, numberofcolors) {\r\n        this.map = [];\r\n        this.lut = [];\r\n        this.n = 256;\r\n        this.minV = 0;\r\n        this.maxV = 1;\r\n        this.setColorMap(colormap, numberofcolors);\r\n    }\r\n    ColorMap.addColorMap = function (colormapName, arrayOfColors) {\r\n        ColorMapKeywords[colormapName] = arrayOfColors;\r\n    };\r\n    Object.defineProperty(ColorMap.prototype, \"mapColors\", {\r\n        get: function () {\r\n            return this.map;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ColorMap.prototype, \"canvas\", {\r\n        get: function () {\r\n            return this.canvas_;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    ColorMap.prototype.set = function (value) {\r\n        if (value instanceof ColorMap) {\r\n            this.copy(value);\r\n        }\r\n        return this;\r\n    };\r\n    Object.defineProperty(ColorMap.prototype, \"length\", {\r\n        get: function () {\r\n            return this.map.length;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    ColorMap.prototype.setMin = function (min) {\r\n        this.minV = min;\r\n        return this;\r\n    };\r\n    ColorMap.prototype.setMax = function (max) {\r\n        this.maxV = max;\r\n        return this;\r\n    };\r\n    ColorMap.prototype.setColorMap = function (colormap, numberofcolors) {\r\n        if (Array.isArray(colormap)) {\r\n            this.map = colormap;\r\n        }\r\n        else {\r\n            this.map = ColorMapKeywords[colormap] || ColorMapKeywords.Rainbow;\r\n        }\r\n        this.n = numberofcolors || 32;\r\n        var step = 1.0 / this.n;\r\n        this.lut = [];\r\n        for (var i = 0; i <= 1; i += step) {\r\n            for (var j = 0; j < this.map.length - 1; j++) {\r\n                if (i >= this.map[j][0] && i < this.map[j + 1][0]) {\r\n                    var min = this.map[j][0];\r\n                    var max = this.map[j + 1][0];\r\n                    // console.log(this.map[j][1], this.map[j + 1][1])\r\n                    var minColor = new Color_1.Color(this.map[j][1]);\r\n                    var maxColor = new Color_1.Color(this.map[j + 1][1]);\r\n                    // console.log(minColor, maxColor)\r\n                    var color = minColor.lerp(maxColor, (i - min) / (max - min));\r\n                    this.lut.push(color);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    ColorMap.prototype.copy = function (lut) {\r\n        this.lut = lut.lut;\r\n        this.map = lut.map;\r\n        this.n = lut.n;\r\n        this.minV = lut.minV;\r\n        this.maxV = lut.maxV;\r\n        return this;\r\n    };\r\n    ColorMap.prototype.getColor = function (alpha) {\r\n        if (alpha <= this.minV) {\r\n            alpha = this.minV;\r\n        }\r\n        else if (alpha >= this.maxV) {\r\n            alpha = this.maxV;\r\n        }\r\n        alpha = (alpha - this.minV) / (this.maxV - this.minV);\r\n        var colorPosition = Math.round(alpha * this.n);\r\n        if (colorPosition === this.n)\r\n            colorPosition -= 1;\r\n        return this.lut[colorPosition];\r\n    };\r\n    ColorMap.prototype.createCanvas = function (parent, width) {\r\n        if (parent === void 0) { parent = document; }\r\n        if (width === void 0) { width = 1; }\r\n        var canvas = parent.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = this.n;\r\n        this.updateCanvas(canvas);\r\n        return canvas;\r\n    };\r\n    ColorMap.prototype.updateCanvas = function (canvas) {\r\n        this.canvas_ = canvas;\r\n        var ctx = canvas.getContext('2d', { alpha: false });\r\n        var k = 0;\r\n        var step = 1.0 / this.n;\r\n        for (var i = 1; i >= 0; i -= step) {\r\n            for (var j = this.map.length - 1; j >= 0; j--) {\r\n                if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\r\n                    var min = this.map[j - 1][0];\r\n                    var max = this.map[j][0];\r\n                    var minColor = new Color_1.Color(this.map[j - 1][1]);\r\n                    var maxColor = new Color_1.Color(this.map[j][1]);\r\n                    var color = minColor.lerp(maxColor, (i - min) / (max - min));\r\n                    ctx.fillStyle = \"rgb(\".concat(Math.round(color.r * 255), \", \").concat(Math.round(color.g * 255), \", \").concat(Math.round(color.b * 255), \")\");\r\n                    ctx.fillRect(0, k, 15, 1);\r\n                    k += 1;\r\n                }\r\n            }\r\n        }\r\n        return canvas;\r\n    };\r\n    return ColorMap;\r\n}());\r\nexports.ColorMap = ColorMap;\r\nvar ColorMapKeywords = {\r\n    'Cooltowarm': [\r\n        [0.0, 0x3C4EC2],\r\n        [0.2, 0x9BBCFF],\r\n        [0.5, 0xDCDCDC],\r\n        [0.8, 0xF6A385],\r\n        [1.0, 0xB40426]\r\n    ],\r\n    'Blackbody': [\r\n        [0.0, 0x000000],\r\n        [0.2, 0x780000],\r\n        [0.5, 0xE63200],\r\n        [0.8, 0xFFFF00],\r\n        [1.0, 0xFFFFFF]\r\n    ],\r\n    'Grayscale': [\r\n        [0.0, 0x000000],\r\n        [0.2, 0x404040],\r\n        [0.5, 0x7F7F80],\r\n        [0.8, 0xBFBFBF],\r\n        [1.0, 0xFFFFFF]\r\n    ],\r\n    'Insar': [\r\n        [0.0, 0x0500d5],\r\n        [0.3, 0x00baff],\r\n        [0.5, 0x00ffc6],\r\n        [0.7, 0xfcff00],\r\n        [1.0, 0xd00000]\r\n    ],\r\n    'InsarBanded': [\r\n        [0, 0x0500d5],\r\n        [0.02040816326530612, 0x00baff],\r\n        [0.04081632653061224, 0x00ffc6],\r\n        [0.061224489795918366, 0xfcff00],\r\n        [0.08163265306122448, 0xd00000],\r\n        [0.1020408163265306, 0x0500d5],\r\n        [0.12244897959183673, 0x00baff],\r\n        [0.14285714285714285, 0x00ffc6],\r\n        [0.16326530612244897, 0xfcff00],\r\n        [0.18367346938775508, 0xd00000],\r\n        [0.2040816326530612, 0x0500d5],\r\n        [0.22448979591836732, 0x00baff],\r\n        [0.24489795918367346, 0x00ffc6],\r\n        [0.26530612244897955, 0xfcff00],\r\n        [0.2857142857142857, 0xd00000],\r\n        [0.3061224489795918, 0x0500d5],\r\n        [0.32653061224489793, 0x00baff],\r\n        [0.3469387755102041, 0x00ffc6],\r\n        [0.36734693877551017, 0xfcff00],\r\n        [0.3877551020408163, 0xd00000],\r\n        [0.4081632653061224, 0x0500d5],\r\n        [0.42857142857142855, 0x00baff],\r\n        [0.44897959183673464, 0x00ffc6],\r\n        [0.4693877551020408, 0xfcff00],\r\n        [0.4897959183673469, 0xd00000],\r\n        [0.5102040816326531, 0x0500d5],\r\n        [0.5306122448979591, 0x00baff],\r\n        [0.5510204081632653, 0x00ffc6],\r\n        [0.5714285714285714, 0xfcff00],\r\n        [0.5918367346938775, 0xd00000],\r\n        [0.6122448979591836, 0x0500d5],\r\n        [0.6326530612244897, 0x00baff],\r\n        [0.6530612244897959, 0x00ffc6],\r\n        [0.673469387755102, 0xfcff00],\r\n        [0.6938775510204082, 0xd00000],\r\n        [0.7142857142857142, 0x0500d5],\r\n        [0.7346938775510203, 0x00baff],\r\n        [0.7551020408163265, 0x00ffc6],\r\n        [0.7755102040816326, 0xfcff00],\r\n        [0.7959183673469387, 0xd00000],\r\n        [0.8163265306122448, 0x0500d5],\r\n        [0.836734693877551, 0x00baff],\r\n        [0.8571428571428571, 0x00ffc6],\r\n        [0.8775510204081632, 0xfcff00],\r\n        [0.8979591836734693, 0xd00000],\r\n        [0.9183673469387754, 0x0500d5],\r\n        [0.9387755102040816, 0x00baff],\r\n        [0.9591836734693877, 0x00ffc6],\r\n        [0.9795918367346939, 0xfcff00],\r\n        [0.9999999999999999, 0xd00000]\r\n    ],\r\n    'Rainbow': [\r\n        [0.0, 0xff0000],\r\n        [0.2, 0xfffc00],\r\n        [0.4, 0x00ff06],\r\n        [0.6, 0x00fffc],\r\n        [0.8, 0x0600ff],\r\n        [1.0, 0xf600ff]\r\n    ],\r\n    'Igeoss': [\r\n        [0.00, 0x003627],\r\n        [0.10, 0x008A3B],\r\n        [0.20, 0x68BE0D],\r\n        [0.30, 0xD6DF00],\r\n        [0.40, 0xFAD000],\r\n        [0.50, 0xFFC010],\r\n        [0.60, 0xFFAE0E],\r\n        [0.70, 0xFF9B06],\r\n        [0.80, 0xFA5800],\r\n        [0.90, 0xE80008],\r\n        [1.00, 0x880003]\r\n    ],\r\n    'Stress': [\r\n        [0.0, 0x0000FF],\r\n        [0.33, 0xFFFFFF],\r\n        [0.331, 0x00C800],\r\n        [0.66, 0xFFFFFF],\r\n        [0.661, 0xFF0000],\r\n        [1.0, 0xFFFFFF]\r\n    ],\r\n    'Blue_White_Red': [\r\n        [0.0, 0x0012ff],\r\n        [0.5, 0xffffff],\r\n        [1.0, 0xff0000]\r\n    ],\r\n    'Blue_Green_Red': [\r\n        [0.0, 0x0012ff],\r\n        [0.25, 0xffffff],\r\n        [0.5, 0x00ff00],\r\n        [0.275, 0xffffff],\r\n        [1.0, 0xff0000]\r\n    ],\r\n    'Spectrum': [\r\n        [0.0000, 0xffffff],\r\n        [0.1428, 0xff0000],\r\n        [0.2856, 0xff00fc],\r\n        [0.4284, 0x0600ff],\r\n        [0.5712, 0x00f6ff],\r\n        [0.7140, 0x00ff06],\r\n        [0.8568, 0xfffc00],\r\n        [1.0000, 0xff0000]\r\n    ],\r\n    'Default': [\r\n        [0.00, 0x0c00ff],\r\n        [0.25, 0x00fcff],\r\n        [0.50, 0x00ff0c],\r\n        [0.75, 0xf6ff00],\r\n        [1.00, 0xff0000]\r\n    ],\r\n    'Banded': [\r\n        [0.0000, 0xfff5cd],\r\n        [0.1666, 0xff9600],\r\n        [0.1667, 0xceffd1],\r\n        [0.3333, 0x107100],\r\n        [0.3334, 0xd4e4fb],\r\n        [0.5000, 0x015faf],\r\n        [0.5001, 0xebdefb],\r\n        [0.6666, 0xc5029e],\r\n        [0.6667, 0xfff0cb],\r\n        [0.8333, 0x845d00],\r\n        [0.8334, 0xf9d8d8],\r\n        [1.0000, 0xda0000]\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://keplerlit/./src/colorMap.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./Color */ \"./src/Color.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./colorMap */ \"./src/colorMap.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./utils */ \"./src/utils.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./IsoContoursFilled */ \"./src/IsoContoursFilled.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./IsoContoursLines */ \"./src/IsoContoursLines.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./attributes */ \"./src/attributes.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./BaseOverlay */ \"./src/BaseOverlay.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./ColorScale */ \"./src/ColorScale.ts\"), exports);\r\n__exportStar(__webpack_require__(/*! ./Compass2D */ \"./src/Compass2D.ts\"), exports);\r\n\n\n//# sourceURL=webpack://keplerlit/./src/index.ts?\n}");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.fromValuesToColors = exports.fromValueToColor = exports.scale = exports.normalize = exports.min = exports.max = exports.minMax = exports.lerp = void 0;\r\nvar colorMap_1 = __webpack_require__(/*! ./colorMap */ \"./src/colorMap.ts\");\r\n/**\r\n * @brief Linearly interpolates between two values. This name is a contraction of \"linear interpolation\"\r\n * @param t The parameter t is clamped to the range [0, 1]\r\n * @param min The minimum value\r\n * @param max The minimum value\r\n * @example\r\n * ```ts\r\n * lerp(0  , 1, 5) // 1\r\n * lerp(0.5, 1, 5) // 3\r\n * lerp(1  , 1, 5) // 5\r\n * ```\r\n * @category Utils\r\n */\r\nvar lerp = function (t, min, max) {\r\n    if (t < 0 || t > 1)\r\n        throw new Error(\"t must be clamped to the range [0,1]. Got \".concat(t));\r\n    return (1 - t) * min + t * max;\r\n};\r\nexports.lerp = lerp;\r\n/**\r\n * @brief Compute the minimum and maximum value of an array in one pass\r\n */\r\nfunction minMax(array) {\r\n    var m = Number.POSITIVE_INFINITY;\r\n    var M = Number.NEGATIVE_INFINITY;\r\n    var n = array.length;\r\n    for (var i = 0; i < n; ++i) {\r\n        var a = array[i];\r\n        if (a < m)\r\n            m = a;\r\n        if (a > M)\r\n            M = a;\r\n    }\r\n    return [m, M];\r\n}\r\nexports.minMax = minMax;\r\n/**\r\n * @brief Compute the maximum value of an array\r\n */\r\nfunction max(array) {\r\n    var m = Number.NEGATIVE_INFINITY;\r\n    var n = array.length;\r\n    for (var i = 0; i < n; ++i) {\r\n        var a = array[i];\r\n        if (a > m)\r\n            m = a;\r\n    }\r\n    return m;\r\n}\r\nexports.max = max;\r\n/**\r\n * @brief Compute the minimum value of an array\r\n */\r\nfunction min(array) {\r\n    var m = Number.POSITIVE_INFINITY;\r\n    var n = array.length;\r\n    for (var i = 0; i < n; ++i) {\r\n        var a = array[i];\r\n        if (a < m)\r\n            m = a;\r\n    }\r\n    return m;\r\n}\r\nexports.min = min;\r\n/**\r\n * @brief Normalize an array of numbers to the range [0, 1]\r\n */\r\nfunction normalize(array) {\r\n    var m = minMax(array);\r\n    return array.map(function (v) { return (v - m[0]) / (m[1] - m[0]); });\r\n}\r\nexports.normalize = normalize;\r\n/**\r\n * @brief Scale an array of numbers by a factor\r\n */\r\nfunction scale(array, s) {\r\n    return array.map(function (v) { return v * s; });\r\n}\r\nexports.scale = scale;\r\n/**\r\n * @param value The value to transform in to a color using a lookup table\r\n * @param params An object to deal with min, max, lut, default-color and reverse table.\r\n * The value **must** be normalized.\r\n * @returns [reg, green, blue]\r\n * @category Lookup Table\r\n */\r\nfunction fromValueToColor(value, _a) {\r\n    var _b = _a.min, min = _b === void 0 ? 0 : _b, _c = _a.max, max = _c === void 0 ? 1 : _c, lutTable = _a.lutTable, defaultColor = _a.defaultColor, _d = _a.reverse, reverse = _d === void 0 ? false : _d;\r\n    if (value < 0 || value > 1) {\r\n        throw new Error(\"value *must% be normalized. Got \".concat(value));\r\n    }\r\n    var w = reverse ? (1.0 - value) : value;\r\n    if (w >= min && w <= max) {\r\n        var c = lutTable.getColor(w);\r\n        return [c.r, c.g, c.b];\r\n    }\r\n    return [defaultColor.r, defaultColor.g, defaultColor.b];\r\n}\r\nexports.fromValueToColor = fromValueToColor;\r\n/**\r\n * @param values\r\n * @param param1\r\n * @returns\r\n * @category Lookup Table\r\n */\r\nfunction fromValuesToColors(values, _a) {\r\n    var defaultColor = _a.defaultColor, lut = _a.lut, _b = _a.duplicateLut, duplicateLut = _b === void 0 ? 1 : _b, _c = _a.min, min = _c === void 0 ? 0 : _c, _d = _a.max, max = _d === void 0 ? 1 : _d, _e = _a.lockLut, lockLut = _e === void 0 ? true : _e, _f = _a.reverse, reverse = _f === void 0 ? false : _f;\r\n    var lutTable = (lut instanceof colorMap_1.ColorMap ? lut : (0, colorMap_1.createLut)(lut, 32, duplicateLut));\r\n    var minmax = minMax(values);\r\n    var vmin = minmax[0];\r\n    var vmax = minmax[1];\r\n    if (lockLut) {\r\n        lutTable.setMin(0).setMax(1);\r\n    }\r\n    else {\r\n        lutTable.setMin(min).setMax(max);\r\n    }\r\n    var colors = new Array(3 * values.length).fill(0);\r\n    values.forEach(function (v, i) {\r\n        var w = reverse ? (v - vmax) / (vmin - vmax) : (v - vmin) / (vmax - vmin);\r\n        if (w >= min && w <= max) {\r\n            var c = lutTable.getColor(w);\r\n            colors[3 * i] = c.r;\r\n            colors[3 * i + 1] = c.g;\r\n            colors[3 * i + 2] = c.b;\r\n        }\r\n        else {\r\n            colors[3 * i] = defaultColor.r;\r\n            colors[3 * i + 1] = defaultColor.g;\r\n            colors[3 * i + 2] = defaultColor.b;\r\n        }\r\n    });\r\n    return colors;\r\n}\r\nexports.fromValuesToColors = fromValuesToColors;\r\n\n\n//# sourceURL=webpack://keplerlit/./src/utils.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});