/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["KeplerLit"] = factory();
	else
		root["KeplerLit"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Color.ts":
/*!**********************!*\
  !*** ./src/Color.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Color = void 0;\nvar Color = /** @class */ (function () {\n    function Color(colorOrRgb) {\n        if (!colorOrRgb) {\n            // Default to black\n            this.r = 0;\n            this.g = 0;\n            this.b = 0;\n        }\n        else if (Array.isArray(colorOrRgb)) {\n            // Array of 3 numbers\n            if (colorOrRgb.length !== 3) {\n                throw new Error('RGB array must have exactly 3 elements');\n            }\n            this.r = colorOrRgb[0];\n            this.g = colorOrRgb[1];\n            this.b = colorOrRgb[2];\n        }\n        else if (typeof colorOrRgb === 'string') {\n            // Hex string\n            if (!/^#([0-9A-F]{3}|[0-9A-F]{6})$/i.test(colorOrRgb)) {\n                throw new Error('Invalid hex color format');\n            }\n            this.setHex(colorOrRgb);\n        }\n        else if (typeof colorOrRgb === 'number') {\n            // Color object\n            // this.r = (colorOrRgb as Color).r\n            // this.g = (colorOrRgb as Color).g\n            // this.b = (colorOrRgb as Color).b\n            // throw new Error('Invalid hex color format')\n            this.setHex(Color.toHexString(colorOrRgb));\n        }\n        else if (typeof colorOrRgb === 'number') {\n            // Color object\n            // this.r = (colorOrRgb as Color).r\n            // this.g = (colorOrRgb as Color).g\n            // this.b = (colorOrRgb as Color).b\n            // throw new Error('Invalid hex color format')\n            this.setHex(Color.toHexString(colorOrRgb));\n        }\n        else if (typeof colorOrRgb === 'object') {\n            // Color object\n            this.r = colorOrRgb.r;\n            this.g = colorOrRgb.g;\n            this.b = colorOrRgb.b;\n        }\n        else {\n            throw new Error(\"Invalid color format. Must be an array of 3 numbers, a hex string, or a Color instance. Got \".concat(colorOrRgb));\n        }\n    }\n    Color.prototype.lerp = function (color, t) {\n        // console.log(this.r, this.g, this.b, color.r, color.g, color.b, t)\n        // console.log(this.r + (color.r - this.r) * t, this.g + (color.g - this.g) * t, this.b + (color.b - this.b) * t)\n        // console.log('---')\n        if (t < 0 || t > 1) {\n            throw new Error('Interpolation factor t must be between 0 and 1');\n        }\n        if (!(color instanceof Color)) {\n            throw new Error('Argument must be an instance of Color');\n        }\n        return new Color({\n            r: this.r + (color.r - this.r) * t,\n            g: this.g + (color.g - this.g) * t,\n            b: this.b + (color.b - this.b) * t\n        });\n    };\n    Color.toHexString = function (color) {\n        return '#' + (color & 0xFFFFFF).toString(16).padStart(6, '0').toUpperCase();\n    };\n    Color.prototype.toHex = function () {\n        var r = Math.round(this.r * 255).toString(16).padStart(2, '0');\n        var g = Math.round(this.g * 255).toString(16).padStart(2, '0');\n        var b = Math.round(this.b * 255).toString(16).padStart(2, '0');\n        return \"#\".concat(r).concat(g).concat(b);\n    };\n    /**\n     * Set from hex string\n     */\n    Color.prototype.setHex = function (hex) {\n        hex = hex.replace('#', '');\n        if (hex.length !== 6) {\n            throw new Error('Invalid hex color format');\n        }\n        this.r = parseInt(hex.substring(0, 2), 16) / 255;\n        this.g = parseInt(hex.substring(2, 4), 16) / 255;\n        this.b = parseInt(hex.substring(4, 6), 16) / 255;\n        return this;\n    };\n    return Color;\n}());\nexports.Color = Color;\n\n\n//# sourceURL=webpack://KeplerLit/./src/Color.ts?\n}");

/***/ }),

/***/ "./src/IsoContoursFilled.ts":
/*!**********************************!*\
  !*** ./src/IsoContoursFilled.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IsoContoursFilled = void 0;\nvar Color_1 = __webpack_require__(/*! ./Color */ \"./src/Color.ts\");\nvar colorMap_1 = __webpack_require__(/*! ./colorMap */ \"./src/colorMap.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar IsoContoursFilled = /** @class */ (function () {\n    /**\n     *\n     * @param lut\n     * @param nbColors\n     * @param isoList The list of iso contours to generate\n     */\n    function IsoContoursFilled(lut, nbColors, isoList) {\n        this.attr = undefined;\n        this.nodes_ = undefined;\n        this.segment_list_ = [];\n        this.vmin_ = 0;\n        this.vmax_ = 1;\n        this.color_ = new Color_1.Color('#000000');\n        this.lutTable_ = (0, colorMap_1.createLut)('Insar', 128);\n        this.position_ = [];\n        this.index_ = [];\n        this.colors_ = [];\n        this.isoValues_ = [];\n        this.normals_ = [];\n        this.nnormals_ = undefined;\n        this.color_ = new Color_1.Color('#000000');\n        this.lutTable_ = (0, colorMap_1.createLut)(lut, nbColors);\n        this.lutTable_.setMin(0);\n        this.lutTable_.setMax(1);\n        this.isoValues_ = isoList;\n    }\n    Object.defineProperty(IsoContoursFilled.prototype, \"position\", {\n        get: function () { return this.position_; },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsoContoursFilled.prototype, \"index\", {\n        get: function () { return this.index_; },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(IsoContoursFilled.prototype, \"color\", {\n        get: function () { return this.colors_; },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     *\n     * @param attr The values at each vertex of the mesh\n     * @param geometry\n     * @param min\n     * @param max\n     * @returns\n     */\n    IsoContoursFilled.prototype.run = function (attr, geometry, min, max) {\n        if (min === void 0) { min = undefined; }\n        if (max === void 0) { max = undefined; }\n        this.attr = attr;\n        var minmax = (0, utils_1.minMax)(this.attr);\n        if (min !== undefined) {\n            this.vmin_ = min;\n        }\n        else {\n            this.vmin_ = minmax[0];\n        }\n        if (max !== undefined) {\n            this.vmax_ = max;\n        }\n        else {\n            this.vmax_ = minmax[1];\n        }\n        if (this.isoValues_.length === 0) {\n            return {\n                position: [],\n                index: [],\n                color: [],\n                normal: []\n            };\n        }\n        var index = geometry.getIndices();\n        var a = index.array;\n        this.nodes_ = geometry.getPositions();\n        this.nnormals_ = geometry.getAttribute('normal');\n        if (this.nnormals_ === undefined) {\n            geometry.computeVertexNormals();\n            this.nnormals_ = geometry.getAttribute('normal');\n        }\n        // The main algo\n        // -------------\n        for (var i = 0; i < a.length; i += 3) { // node indices of a triangle\n            this.classify(a[i], a[i + 1], a[i + 2]);\n        }\n        return {\n            position: this.position_,\n            index: this.index_,\n            color: this.colors_,\n            normal: this.normals_\n        };\n    };\n    IsoContoursFilled.prototype.normalizeAttr = function (v) {\n        return (v - this.vmin_) / (this.vmax_ - this.vmin_);\n    };\n    IsoContoursFilled.prototype.getNode = function (i) {\n        return this.nodes_.get(i);\n        // return [this.nodes_.getX(i), this.nodes_.getY(i), this.nodes_.getZ(i)]\n    };\n    IsoContoursFilled.prototype.getNormal = function (i) {\n        return this.nnormals_.get(i);\n        // return [this.nnormals_.getX(i), this.nnormals_.getY(i), this.nnormals_.getZ(i)]\n    };\n    IsoContoursFilled.prototype.getAttr = function (i) {\n        return this.attr[i];\n    };\n    IsoContoursFilled.prototype.classify = function (n0, n1, n2) {\n        var t = new TriInfo;\n        t.v1 = this.getAttr(n0);\n        t.p1 = this.getNode(n0);\n        t.n1 = this.getNormal(n0);\n        t.v2 = this.getAttr(n1);\n        t.p2 = this.getNode(n1);\n        t.n2 = this.getNormal(n1);\n        t.v3 = this.getAttr(n2);\n        t.p3 = this.getNode(n2);\n        t.n3 = this.getNormal(n2);\n        var nn1, nn2, nn3;\n        var vv1, vv2, vv3;\n        var hh1 = 0, hh2 = 0, hh3 = 0;\n        if (t.v1 <= t.v2 && t.v1 <= t.v3) {\n            vv1 = t.p1;\n            hh1 = t.v1;\n            nn1 = t.n1;\n            if (t.v2 <= t.v3) {\n                vv2 = t.p2;\n                vv3 = t.p3;\n                hh2 = t.v2;\n                hh3 = t.v3;\n                nn2 = t.n2;\n                nn3 = t.n3;\n            }\n            else {\n                vv2 = t.p3;\n                vv3 = t.p2;\n                hh2 = t.v3;\n                hh3 = t.v2;\n                nn2 = t.n3;\n                nn3 = t.n2;\n                t.reversed = true;\n            }\n        }\n        else if (t.v2 <= t.v1 && t.v2 <= t.v3) {\n            vv1 = t.p2;\n            hh1 = t.v2;\n            nn1 = t.n2;\n            if (t.v1 <= t.v3) {\n                vv2 = t.p1;\n                vv3 = t.p3;\n                hh2 = t.v1;\n                hh3 = t.v3;\n                nn2 = t.n1;\n                nn3 = t.n3;\n                t.reversed = true;\n            }\n            else {\n                vv2 = t.p3;\n                vv3 = t.p1;\n                hh2 = t.v3;\n                hh3 = t.v1;\n                nn2 = t.n3;\n                nn3 = t.n1;\n            }\n        }\n        else if (t.v3 <= t.v1 && t.v3 <= t.v2) {\n            vv1 = t.p3;\n            hh1 = t.v3;\n            nn1 = t.n3;\n            if (t.v1 <= t.v2) {\n                vv2 = t.p1;\n                vv3 = t.p2;\n                hh2 = t.v1;\n                hh3 = t.v2;\n                nn2 = t.n1;\n                nn3 = t.n2;\n            }\n            else {\n                vv2 = t.p2;\n                vv3 = t.p1;\n                hh2 = t.v2;\n                hh3 = t.v1;\n                nn2 = t.n2;\n                nn3 = t.n1;\n                t.reversed = true;\n            }\n        }\n        else {\n            return;\n        }\n        t.p1 = vv1;\n        t.p2 = vv2;\n        t.p3 = vv3;\n        t.v1 = hh1;\n        t.v2 = hh2;\n        t.v3 = hh3;\n        t.n1 = nn1;\n        t.n2 = nn2;\n        t.n3 = nn3;\n        this.createSegmentList(t); // for this current traingle\n        this.createPolygons(t);\n        n1 = n2;\n    };\n    IsoContoursFilled.prototype.createSegmentList = function (t) {\n        this.segment_list_ = [];\n        t.notIntersectedPolygonValue = this.vmin_;\n        for (var _i = 0, _a = this.isoValues_; _i < _a.length; _i++) {\n            var iso = _a[_i];\n            if (iso >= t.v3)\n                break;\n            if (iso > t.v1) {\n                this.addSegment(iso, t);\n            }\n            else {\n                t.notIntersectedPolygonValue = iso;\n            }\n        }\n    };\n    IsoContoursFilled.prototype.addSegment = function (iso, t) {\n        var segment = new IsoSegment;\n        segment.iso = iso;\n        var v1 = t.v1;\n        var v2 = t.v2;\n        var v3 = t.v3;\n        var p1 = t.p1;\n        var p2 = t.p2;\n        var p3 = t.p3;\n        if (iso < t.v2) {\n            var w1 = isoValue(v1, v2, iso);\n            var w2 = isoValue(v1, v3, iso);\n            segment.p1 = createPoint(p1, p2, w1);\n            segment.p2 = createPoint(p1, p3, w2);\n            segment.n1 = createPoint(t.n1, t.n2, w1);\n            segment.n2 = createPoint(t.n1, t.n3, w2);\n        }\n        else {\n            var w1 = isoValue(v2, v3, iso);\n            var w2 = isoValue(v1, v3, iso);\n            segment.p1 = createPoint(p2, p3, w1);\n            segment.p2 = createPoint(p1, p3, w2);\n            segment.n1 = createPoint(t.n2, t.n3, w1);\n            segment.n2 = createPoint(t.n1, t.n3, w2);\n        }\n        this.segment_list_.push(segment);\n    };\n    IsoContoursFilled.prototype.createPolygons = function (t) {\n        if ((t.v1 < this.vmin_ || t.v1 > this.vmax_) &&\n            (t.v2 < this.vmin_ || t.v2 > this.vmax_) &&\n            (t.v3 < this.vmin_ || t.v3 > this.vmax_)) {\n            return; // <-------------------------------\n        }\n        var negate = function (n) { return [-n[0], -n[1], -n[2]]; };\n        var bypass = false;\n        if (t.reversed) {\n            if (this.segment_list_.length === 0) {\n                this.addTri(t.p1, t.p3, t.p2, t.n1, t.n3, t.n2, t.notIntersectedPolygonValue);\n                return;\n            }\n            var seg = front(this.segment_list_);\n            if (seg.iso < t.v2) {\n                this.addTri(t.p1, seg.p2, seg.p1, t.n1, seg.n2, seg.n1, t.notIntersectedPolygonValue);\n            }\n            else {\n                bypass = true;\n                this.addQuad(t.p1, seg.p2, seg.p1, t.p2, t.n1, seg.n2, seg.n1, t.n2, t.notIntersectedPolygonValue);\n            }\n            for (var i = 1; i < this.segment_list_.length; ++i) {\n                var seg1 = this.segment_list_[i];\n                if (seg1.iso < t.v2) {\n                    this.addQuad(seg.p1, seg1.p1, seg1.p2, seg.p2, negate(seg.n1), negate(seg1.n1), negate(seg1.n2), negate(seg.n2), seg.iso);\n                }\n                else {\n                    if (bypass) {\n                        this.addQuad(seg.p1, seg.p2, seg1.p2, seg1.p1, seg.n1, seg.n2, seg1.n2, seg1.n1, seg.iso);\n                    }\n                    else {\n                        bypass = true;\n                        this.addPoly(t.p2, seg.p1, seg.p2, seg1.p2, seg1.p1, t.n2, seg.n1, seg.n2, seg1.n2, seg1.n1, seg.iso);\n                    }\n                }\n                seg = seg1;\n            }\n            seg = back(this.segment_list_);\n            if (bypass) {\n                this.addTri(seg.p1, seg.p2, t.p3, seg.n1, seg.n2, t.n3, seg.iso);\n            }\n            else {\n                this.addQuad(t.p2, seg.p1, seg.p2, t.p3, t.n2, seg.n1, seg.n2, t.n3, seg.iso);\n            }\n        }\n        //draw polygons in CW\n        else {\n            if (this.segment_list_.length === 0) {\n                this.addTri(t.p1, t.p2, t.p3, t.n1, t.n2, t.n3, t.notIntersectedPolygonValue);\n                return;\n            }\n            var seg = front(this.segment_list_);\n            if (seg.iso < t.v2) {\n                this.addTri(t.p1, seg.p1, seg.p2, t.n1, seg.n1, seg.n2, t.notIntersectedPolygonValue);\n            }\n            else {\n                bypass = true;\n                this.addQuad(t.p1, t.p2, seg.p1, seg.p2, t.n1, t.n2, seg.n1, seg.n2, t.notIntersectedPolygonValue);\n            }\n            for (var i = 1; i < this.segment_list_.length; ++i) {\n                var seg1 = this.segment_list_[i];\n                if (seg1.iso < t.v2) {\n                    this.addQuad(seg.p1, seg1.p1, seg1.p2, seg.p2, seg.n1, seg1.n1, seg1.n2, seg.n2, seg.iso);\n                }\n                else {\n                    if (bypass) {\n                        this.addQuad(seg.p1, seg1.p1, seg1.p2, seg.p2, seg.n1, seg1.n1, seg1.n2, seg.n2, seg.iso);\n                    }\n                    else {\n                        bypass = true;\n                        this.addPoly(t.p2, seg1.p1, seg1.p2, seg.p2, seg.p1, t.n2, seg1.n1, seg1.n2, seg.n2, seg.n1, seg.iso);\n                    }\n                }\n                seg = seg1;\n            }\n            seg = back(this.segment_list_);\n            if (bypass) {\n                this.addTri(seg.p1, t.p3, seg.p2, seg.n1, t.n3, seg.n2, seg.iso);\n            }\n            else {\n                this.addQuad(t.p2, t.p3, seg.p2, seg.p1, t.n2, t.n3, seg.n2, seg.n1, seg.iso);\n            }\n        }\n    };\n    IsoContoursFilled.prototype.addTri = function (point1, point2, point3, n1, n2, n3, iso) {\n        var _a, _b, _c;\n        if (iso < this.vmin_ || iso > this.vmax_)\n            return;\n        var c = (0, utils_1.fromValueToColor)(this.normalizeAttr(iso), {\n            defaultColor: this.color_,\n            lutTable: this.lutTable_\n        });\n        var id = this.position_.length / 3;\n        (_a = this.position_).push.apply(_a, __spreadArray(__spreadArray(__spreadArray([], point1, false), point2, false), point3, false));\n        this.index_.push(id, id + 1, id + 2);\n        (_b = this.colors_).push.apply(_b, __spreadArray(__spreadArray(__spreadArray([], c, false), c, false), c, false));\n        (_c = this.normals_).push.apply(_c, __spreadArray(__spreadArray(__spreadArray([], n1, false), n2, false), n3, false));\n    };\n    IsoContoursFilled.prototype.addQuad = function (point1, point2, point3, point4, n1, n2, n3, n4, iso) {\n        var _a, _b, _c;\n        if (iso < this.vmin_ || iso > this.vmax_)\n            return;\n        var c = (0, utils_1.fromValueToColor)(this.normalizeAttr(iso), {\n            defaultColor: this.color_,\n            lutTable: this.lutTable_\n        });\n        var id = this.position_.length / 3;\n        (_a = this.position_).push.apply(_a, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], point1, false), point2, false), point3, false), point4, false));\n        this.index_.push(id, id + 1, id + 2, id, id + 2, id + 3);\n        (_b = this.colors_).push.apply(_b, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], c, false), c, false), c, false), c, false));\n        (_c = this.normals_).push.apply(_c, __spreadArray(__spreadArray(__spreadArray(__spreadArray([], n1, false), n2, false), n3, false), n4, false));\n    };\n    IsoContoursFilled.prototype.addPoly = function (point1, point2, point3, point4, point5, n1, n2, n3, n4, n5, iso) {\n        var _a, _b, _c;\n        if (iso < this.vmin_ || iso > this.vmax_)\n            return;\n        var c = (0, utils_1.fromValueToColor)(this.normalizeAttr(iso), {\n            defaultColor: this.color_,\n            lutTable: this.lutTable_\n        });\n        var id = this.position_.length / 3;\n        (_a = this.position_).push.apply(_a, __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], point1, false), point2, false), point3, false), point4, false), point5, false));\n        this.index_.push(id, id + 1, id + 2, id, id + 2, id + 3, id, id + 3, id + 4);\n        (_b = this.colors_).push.apply(_b, __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], c, false), c, false), c, false), c, false), c, false));\n        (_c = this.normals_).push.apply(_c, __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], n1, false), n2, false), n3, false), n4, false), n5, false));\n    };\n    return IsoContoursFilled;\n}());\nexports.IsoContoursFilled = IsoContoursFilled;\n// -------------------------------------------\nvar IsoSegment = /** @class */ (function () {\n    function IsoSegment() {\n        this.p1 = [0, 0, 0];\n        this.p2 = [0, 0, 0];\n        this.n1 = [0, 0, 1];\n        this.n2 = [0, 0, 1];\n        this.iso = 0;\n    }\n    return IsoSegment;\n}());\nvar TriInfo = /** @class */ (function () {\n    function TriInfo() {\n        this.reversed = false;\n        this.p1 = [0, 0, 0];\n        this.p2 = [0, 0, 0];\n        this.p3 = [0, 0, 0];\n        this.n1 = [1, 0, 0];\n        this.n2 = [1, 0, 0];\n        this.n3 = [1, 0, 0];\n        this.v1 = 0;\n        this.v2 = 0;\n        this.v3 = 0;\n        this.notIntersectedPolygonValue = 0;\n    }\n    return TriInfo;\n}());\nvar front = function (container) { return container[0]; };\nvar back = function (container) { return container[container.length - 1]; };\nfunction createPoint(p1, p2, w) {\n    var W = 1. - w;\n    return [\n        w * p1[0] + W * p2[0],\n        w * p1[1] + W * p2[1],\n        w * p1[2] + W * p2[2]\n    ];\n}\nfunction isoValue(v1, v2, iso) {\n    return 1. - (Math.abs(iso - v1) / Math.abs(v2 - v1));\n}\n\n\n//# sourceURL=webpack://KeplerLit/./src/IsoContoursFilled.ts?\n}");

/***/ }),

/***/ "./src/IsoContoursLines.ts":
/*!*********************************!*\
  !*** ./src/IsoContoursLines.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createIsoContourLines = void 0;\nvar Color_1 = __webpack_require__(/*! ./Color */ \"./src/Color.ts\");\nvar colorMap_1 = __webpack_require__(/*! ./colorMap */ \"./src/colorMap.ts\");\nvar MarchingTriangle_1 = __webpack_require__(/*! ./MarchingTriangle */ \"./src/MarchingTriangle.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nfunction createIsoContourLines(mesh, attribute, isoList, defaultColor, lut) {\n    var _this = this;\n    if (mesh === undefined) {\n        throw new Error('mesh is undefined');\n    }\n    if (mesh.getPositions() === undefined) {\n        throw new Error('mesh.positions is undefined');\n    }\n    if (mesh.getIndices() === undefined) {\n        throw new Error('mesh.indices is undefined');\n    }\n    if (attribute === undefined) {\n        throw new Error('attribute is undefined');\n    }\n    var mm = (0, utils_1.minMax)(attribute);\n    var vmin = mm[0];\n    var vmax = mm[1];\n    var lutTable = undefined;\n    if (lut === undefined || lut === null) {\n        lutTable = (0, colorMap_1.createLut)(lut, 128);\n        lutTable.setMin(vmin);\n        lutTable.setMax(vmax);\n    }\n    var dColor = new Color_1.Color(defaultColor);\n    var isoValues = isoList;\n    var algo = new MarchingTriangle_1.MarchingTriangles();\n    algo.setup(mesh.getIndices(), [vmin, vmax]);\n    var vertices = mesh.getPositions();\n    var positions = [];\n    var colors = [];\n    var normalizeAttr = function (v) { return (v - _this.vmin_) / (_this.vmax_ - _this.vmin_); };\n    for (var i = 0; i < isoValues.length; ++i) {\n        var result = algo.isolines(attribute, isoValues[i]);\n        var c = (0, utils_1.fromValueToColor)(normalizeAttr(isoValues[i]), {\n            min: vmin,\n            max: vmax,\n            defaultColor: dColor,\n            lutTable: lutTable\n        });\n        colors.push.apply(colors, c);\n        for (var k = 0; k < result[0].length; ++k) {\n            for (var l = 0; l < result[0][k].length - 2; l += 2) {\n                var i1 = result[0][k][l];\n                var i2 = result[0][k][l + 1];\n                var c_1 = result[1][k][l / 2];\n                var v1 = vertices.get(i1);\n                var v2 = vertices.get(i2);\n                var v1x = v1[0];\n                var v1y = v1[1];\n                var v1z = v1[2];\n                var v2x = v2[0];\n                var v2y = v2[1];\n                var v2z = v2[2];\n                positions.push(v1x + c_1 * (v2x - v1x), v1y + c_1 * (v2y - v1y), v1z + c_1 * (v2z - v1z));\n            }\n        }\n    }\n    return {\n        positions: positions,\n        color: colors\n    };\n}\nexports.createIsoContourLines = createIsoContourLines;\n\n\n//# sourceURL=webpack://KeplerLit/./src/IsoContoursLines.ts?\n}");

/***/ }),

/***/ "./src/MarchingTriangle.ts":
/*!*********************************!*\
  !*** ./src/MarchingTriangle.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MarchingTriangles = void 0;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar MarchingTriangles = /** @class */ (function () {\n    function MarchingTriangles() {\n        this.topo_ = [];\n        this.lock_ = false;\n        this.maxVertexIndex_ = -1;\n        this._bounds = [];\n    }\n    // topo of type BufferAttribute (with item count corresponding to 1 id)\n    MarchingTriangles.prototype.setup = function (topo, bounds) {\n        this.lock_ = false;\n        this.maxVertexIndex_ = -1;\n        this._bounds = bounds;\n        this.topo_ = [];\n        for (var l = 0; l < topo.array.length; l += 3) {\n            var i = topo.array[l];\n            var j = topo.array[l + 1];\n            var k = topo.array[l + 2];\n            this.topo_.push({ i: i, j: j, k: k });\n            if (i === j || i === k || j === k) {\n                throw new Error(\"Error in topology while setting up iso-contouring in 'MarchingTriangles.' At index \".concat(l, \", got 3 indices (\").concat(i, \", \").concat(j, \", \").concat(k, \")\"));\n            }\n            this.maxVertexIndex_ = Math.max(this.maxVertexIndex_, i, j, k);\n        }\n        // topo.forEach((value: number[], index: number) => {\n        //     let i = value[0]\n        //     let j = value[1]\n        //     let k = value[2]\n        //     this.topo_.push({ i, j, k })\n        //     if (i === j || i === k || j === k) {\n        //         throw new Error(`Error in topology while setting up iso-contouring in 'MarchingTriangles.' At index ${index}, got 3 indices (${i}, ${j}, ${k})`)\n        //     }\n        //     this.maxVertexIndex_ = Math.max(this.maxVertexIndex_, i, j, k)\n        // })\n        this.lock_ = true;\n        return true;\n    };\n    /**\n     * Return array of size 2:\n     *\n     * 1) result[0] represents the connected isoline edges\n     *\n     * 2) result[1] represents the connected isoline values\n     */\n    MarchingTriangles.prototype.isolines = function (prop, isovalue) {\n        var result = [[]];\n        if (this.lock_ === false) {\n            return result;\n        }\n        if (prop.length < 0) {\n            return result;\n        }\n        if (this._bounds === undefined) {\n            this._bounds = (0, utils_1.minMax)(prop);\n        }\n        // Store the triangles cross by the iso-surface and for\n        // each triangle i stored its value [1,6]\n        var tri2code = new Map();\n        var cut_edges = [];\n        var triangle = [0, 0, 0];\n        var connectiviy = new Map(new Map());\n        for (var i = 0; i < this.topo_.length; ++i) {\n            triangle[0] = this.topo_[i].i;\n            triangle[1] = this.topo_[i].j;\n            triangle[2] = this.topo_[i].k;\n            var t1 = void 0, t2 = void 0, t3 = void 0;\n            var p0 = prop[triangle[0]];\n            var p1 = prop[triangle[1]];\n            var p2 = prop[triangle[2]];\n            if (ok(p0, p1, p2, this._bounds[0], this._bounds[1]) === false) {\n                continue;\n            }\n            if ((p0 >= isovalue)) {\n                t1 = 1;\n            }\n            else {\n                t1 = 0;\n            }\n            if ((p1 >= isovalue)) {\n                t2 = 1;\n            }\n            else {\n                t2 = 0;\n            }\n            if ((p2 >= isovalue)) {\n                t3 = 1;\n            }\n            else {\n                t3 = 0;\n            }\n            var tri_code = lookupTable1[t1][t2][t3];\n            // means that this triangle is cut by the isoline\n            if (tri_code > 0 && tri_code < 7) {\n                tri2code.set(i, tri_code);\n                cut_edges[0] = lookupTable0[tri_code][0];\n                cut_edges[1] = lookupTable0[tri_code][1];\n                for (var e = 0; e < 2; ++e) {\n                    var v0 = cut_edges[e];\n                    var v1 = (v0 + 1) % 3;\n                    v0 = triangle[v0];\n                    v1 = triangle[v1];\n                    var vmin = Math.min(v0, v1);\n                    var vmax = Math.max(v0, v1);\n                    if (!(vmin in connectiviy)) {\n                        var vmax_2_triangles = new Map();\n                        vmax_2_triangles.set(vmax, [i]);\n                        connectiviy.set(vmin, vmax_2_triangles);\n                    }\n                    else {\n                        connectiviy.get(vmin).get(vmax).push(i);\n                    }\n                }\n            }\n        }\n        // Extraction...\n        do {\n            if (tri2code.size <= 0)\n                break;\n            var isoline = [];\n            var values = [];\n            var start = tri2code.keys();\n            var first_tri = start.next().value;\n            var code = tri2code.get(first_tri);\n            tri2code.delete(tri2code.keys().next().value);\n            if (code < 1 || code > 6) {\n                continue;\n            }\n            triangle[0] = this.topo_[first_tri].i;\n            triangle[1] = this.topo_[first_tri].j;\n            triangle[2] = this.topo_[first_tri].k;\n            cut_edges[0] = lookupTable0[code][0];\n            cut_edges[1] = lookupTable0[code][1];\n            var first_edge = [];\n            var next_edge = [];\n            for (var e = 0; e < 2; ++e) {\n                var v0 = cut_edges[e];\n                var v1 = (v0 + 1) % 3;\n                v0 = triangle[v0];\n                v1 = triangle[v1];\n                isoline.push(v0);\n                isoline.push(v1);\n                values.push((isovalue - prop[v0]) / (prop[v1] - prop[v0]));\n                var vmin = Math.min(v0, v1);\n                var vmax = Math.max(v0, v1);\n                if (e === 0) {\n                    first_edge[0] = vmin;\n                    first_edge[1] = vmax;\n                }\n                else {\n                    next_edge[0] = vmin;\n                    next_edge[1] = vmax;\n                }\n            }\n            var first_e = 0;\n            var nb_loop = 0;\n            do {\n                var current_tri = first_tri;\n                do {\n                    var adj_trgls = [connectiviy.get(next_edge[0]).get(next_edge[1])];\n                    if (adj_trgls.length === 1) {\n                        break; // border\n                    }\n                    current_tri = adj_trgls[0] + adj_trgls[1] - current_tri;\n                    var iter = tri2code.get(current_tri);\n                    if (!(iter in tri2code)) {\n                        break;\n                    }\n                    code = iter.second;\n                    tri2code.delete(iter);\n                    // let f = this.topo_[current_tri] ;\n                    triangle[0] = this.topo_[current_tri].i;\n                    triangle[1] = this.topo_[current_tri].j;\n                    triangle[2] = this.topo_[current_tri].k;\n                    cut_edges[0] = lookupTable0[code][0];\n                    cut_edges[1] = lookupTable0[code][1];\n                    for (var e = 0; e < 2; ++e) {\n                        var v0 = cut_edges[e];\n                        var v1 = (v0 + 1) % 3;\n                        v0 = triangle[v0];\n                        v1 = triangle[v1];\n                        var vmin = Math.min(v0, v1);\n                        var vmax = Math.max(v0, v1);\n                        if (vmin !== next_edge[0] || vmax !== next_edge[1]) {\n                            isoline.push(v0);\n                            isoline.push(v1);\n                            values.push((isovalue - prop[v0]) / (prop[v1] - prop[v0]));\n                            next_edge[0] = vmin;\n                            next_edge[1] = vmax;\n                            break;\n                        }\n                    }\n                } while (true);\n                if (next_edge[0] === first_edge[0] && next_edge[1] === first_edge[1]) {\n                    // Closed line\n                    isoline.push(isoline[0]);\n                    isoline.push(isoline[1]);\n                    values.push(values[0]);\n                    first_e = values.length;\n                    break;\n                }\n                else if (nb_loop === 0) {\n                    next_edge[0] = first_edge[0];\n                    next_edge[1] = first_edge[1];\n                    first_e = values.length;\n                }\n                ++nb_loop;\n            } while (nb_loop < 2);\n            if (first_e === values.length) {\n                result[0].push(isoline);\n                if (result[1] === undefined) {\n                    result[1] = [values];\n                }\n                else {\n                    result[1].push(values);\n                }\n            }\n            else {\n                var connected_isoline_edges = [];\n                var connected_isoline_values = [];\n                for (var j = isoline.length - 1; j >= 2 * first_e; --j) {\n                    connected_isoline_edges.push(isoline[j]);\n                }\n                for (var j = values.length - 1; j >= first_e; --j) {\n                    connected_isoline_values.push(1.0 - values[j]);\n                }\n                for (var j = 0; j < 2 * first_e; ++j) {\n                    connected_isoline_edges.push(isoline[j]);\n                }\n                for (var j = 0; j < first_e; ++j) {\n                    connected_isoline_values.push(values[j]);\n                }\n                result[0].push(connected_isoline_edges);\n                result[1].push(connected_isoline_values);\n            }\n        } while (true);\n        return result;\n    };\n    return MarchingTriangles;\n}());\nexports.MarchingTriangles = MarchingTriangles;\nfunction ok(p0, p1, p2, min, max) {\n    function _in(p, min, max) {\n        return p >= min && p <= max;\n    }\n    return _in(p0, min, max) && _in(p1, min, max) && _in(p2, min, max);\n}\nvar lookupTable0 = [[-1, -1], [1, 2], [0, 1], [2, 0], [2, 0], [0, 1], [1, 2], [-1, -1]];\nvar lookupTable1 = [[[0, 1], [2, 3]], [[4, 5], [6, 7]]];\n\n\n//# sourceURL=webpack://KeplerLit/./src/MarchingTriangle.ts?\n}");

/***/ }),

/***/ "./src/attributes.ts":
/*!***************************!*\
  !*** ./src/attributes.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports) {

eval("{\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.Float32BufferAttribute = exports.BufferGeometry = exports.BufferAttribute = void 0;\n/**\n * BufferAttribute class for handling typed arrays in WebGL.\n *\n * We rewrite it in order to avoid using the THREE.js library if necessary.\n *\n * @param array - The typed array (Float32Array, Uint16Array, or Uint32Array)\n * @param itemSize - Number of components per item (e.g., 3 for vec3)\n * @param normalized - Whether the attribute is normalized (default: false)\n * @param usage - WebGL usage hint (default: STATIC_DRAW)\n * @param updateRange - Range of items to update (default: entire array)\n * @param version - Version number for tracking changes (default: 0)\n * @param needsUpdate - Whether the attribute needs to be updated (default: false)\n *\n * Example usage:\n * @example\n * // Create position attribute (3 components per vertex)\n * const positions = new Float32BufferAttribute([\n *   0, 0, 0,    // vertex 0\n *   1, 0, 0,    // vertex 1\n *   0, 1, 0     // vertex 2\n * ], 3);\n *\n * // Set vertex at index 1\n * positions.set(1, [2, 0, 0]);\n *\n * // Get vertex at index 0\n * const vertex0 = positions.get(0); // [0, 0, 0]\n *\n * // Set individual component\n * positions.setComponent(2, 2, 1); // Set z-component of vertex 2 to 1\n *\n * // Create color attribute (4 components: RGBA)\n * const colors = new Float32BufferAttribute([\n *   1, 0, 0, 1,    // red\n *   0, 1, 0, 1,    // green\n *   0, 0, 1, 1     // blue\n * ], 4);\n *\n * // Get color of vertex 1\n * const color1 = colors.get(1); // [0, 1, 0, 1]\n *\n * // Create UV coordinates (2 components per vertex)\n * const uvs = new Float32BufferAttribute([\n *   0, 0,    // vertex 0\n *   1, 0,    // vertex 1\n *   0, 1     // vertex 2\n * ], 2);\n *\n * // Copy vertex 0 UV to vertex 2\n * uvs.copyAt(2, uvs, 0);\n *\n * // Apply transformation to all positions\n * positions.forEach((values, index) => {\n *   return [values[0] * 2, values[1] * 2, values[2] * 2]; // Scale by 2\n * });\n */\nvar BufferAttribute = /** @class */ (function () {\n    function BufferAttribute(array, itemSize, normalized) {\n        if (normalized === void 0) { normalized = false; }\n        this.array = array;\n        this.itemSize = itemSize;\n        this.count = array.length / itemSize;\n        this.normalized = normalized;\n        this.usage = 35044; // WebGL STATIC_DRAW\n        this.updateRange = { offset: 0, count: -1 };\n        this.version = 0;\n        this.needsUpdate = false;\n    }\n    /**\n     * Set values at a specific index\n     * @param index - The index of the item (not the array index)\n     * @param values - Array of values, must be of length itemSize\n     */\n    BufferAttribute.prototype.set = function (index, values) {\n        if (values.length !== this.itemSize) {\n            throw new Error(\"Expected \".concat(this.itemSize, \" values, got \").concat(values.length));\n        }\n        if (index < 0 || index >= this.count) {\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\n        }\n        var startIndex = index * this.itemSize;\n        for (var i = 0; i < this.itemSize; i++) {\n            this.array[startIndex + i] = values[i];\n        }\n        this.needsUpdate = true;\n        return this;\n    };\n    /**\n     * Get values at a specific index\n     * @param index - The index of the item (not the array index)\n     * @returns Array of values of length itemSize\n     */\n    BufferAttribute.prototype.get = function (index) {\n        if (index < 0 || index >= this.count) {\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\n        }\n        var startIndex = index * this.itemSize;\n        var result = [];\n        for (var i = 0; i < this.itemSize; i++) {\n            result.push(this.array[startIndex + i]);\n        }\n        return result;\n    };\n    /**\n     * @brief Get the x component of an item at a specific index.\n     * Similar to get(index)[0], but optimized for performance.\n     */\n    BufferAttribute.prototype.getX = function (index) {\n        if (index < 0 || index >= this.count) {\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\n        }\n        return this.array[index * this.itemSize];\n    };\n    /**\n     * @brief Get the y component of an item at a specific index.\n     * * Similar to get(index)[1], but optimized for performance.\n     */\n    BufferAttribute.prototype.getY = function (index) {\n        if (this.itemSize < 2) {\n            throw new Error(\"Item size is \".concat(this.itemSize, \", cannot get Y component\"));\n        }\n        return this.array[index * this.itemSize + 1];\n    };\n    /**\n     * @brief Get the z component of an item at a specific index.\n     * * Similar to get(index)[2], but optimized for performance.\n     */\n    BufferAttribute.prototype.getZ = function (index) {\n        if (this.itemSize < 3) {\n            throw new Error(\"Item size is \".concat(this.itemSize, \", cannot get Z component\"));\n        }\n        return this.array[index * this.itemSize + 2];\n    };\n    /**\n     * Set a single component value at a specific index and component\n     * @param index - The index of the item\n     * @param component - The component index (0 to itemSize-1)\n     * @param value - The value to set\n     */\n    BufferAttribute.prototype.setComponent = function (index, component, value) {\n        if (index < 0 || index >= this.count) {\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\n        }\n        if (component < 0 || component >= this.itemSize) {\n            throw new Error(\"Component \".concat(component, \" out of range [0, \").concat(this.itemSize - 1, \"]\"));\n        }\n        this.array[index * this.itemSize + component] = value;\n        this.needsUpdate = true;\n        return this;\n    };\n    /**\n     * Get a single component value at a specific index and component\n     * @param index - The index of the item\n     * @param component - The component index (0 to itemSize-1)\n     * @returns The component value\n     */\n    BufferAttribute.prototype.getComponent = function (index, component) {\n        if (index < 0 || index >= this.count) {\n            throw new Error(\"Index \".concat(index, \" out of range [0, \").concat(this.count - 1, \"]\"));\n        }\n        if (component < 0 || component >= this.itemSize) {\n            throw new Error(\"Component \".concat(component, \" out of range [0, \").concat(this.itemSize - 1, \"]\"));\n        }\n        return this.array[index * this.itemSize + component];\n    };\n    /**\n     * Copy data from another BufferAttribute\n     * @param source - The source BufferAttribute\n     */\n    BufferAttribute.prototype.copy = function (source) {\n        this.array = source.array.slice();\n        this.itemSize = source.itemSize;\n        this.count = source.count;\n        this.normalized = source.normalized;\n        this.usage = source.usage;\n        this.updateRange = __assign({}, source.updateRange);\n        this.version = source.version;\n        this.needsUpdate = source.needsUpdate;\n        return this;\n    };\n    /**\n     * Copy an item from another BufferAttribute at different indices\n     * @param index1 - Target index in this attribute\n     * @param attribute - Source BufferAttribute\n     * @param index2 - Source index in the source attribute\n     */\n    BufferAttribute.prototype.copyAt = function (index1, attribute, index2) {\n        if (this.itemSize !== attribute.itemSize) {\n            throw new Error(\"ItemSize mismatch: \".concat(this.itemSize, \" vs \").concat(attribute.itemSize));\n        }\n        var values = attribute.get(index2);\n        this.set(index1, values);\n        return this;\n    };\n    /**\n     * Clone this BufferAttribute\n     * @returns A new BufferAttribute with the same data\n     */\n    BufferAttribute.prototype.clone = function () {\n        var TypedArrayConstructor = this.array.constructor;\n        var clonedArray = new TypedArrayConstructor(this.array);\n        return new BufferAttribute(clonedArray, this.itemSize, this.normalized);\n    };\n    /**\n     * Set the usage hint for WebGL\n     * @param usage - WebGL usage constant\n     */\n    BufferAttribute.prototype.setUsage = function (usage) {\n        this.usage = usage;\n        return this;\n    };\n    /**\n     * Get the size in bytes of the array\n     */\n    BufferAttribute.prototype.getByteLength = function () {\n        return this.array.byteLength;\n    };\n    /**\n     * Apply a function to each item in the attribute\n     * @param callback - Function to apply, receives (values, index) and should return new values\n     */\n    BufferAttribute.prototype.forEach = function (callback) {\n        for (var i = 0; i < this.count; i++) {\n            var currentValues = this.get(i);\n            callback(currentValues, i);\n        }\n        return this;\n    };\n    return BufferAttribute;\n}());\nexports.BufferAttribute = BufferAttribute;\n/**\n * BufferGeometry class for handling multiple BufferAttributes + one for the geometry and one for the indices\n */\nvar BufferGeometry = /** @class */ (function () {\n    function BufferGeometry(positions, indices) {\n        this.attributes = {};\n        this.positions = null;\n        this.indices = null;\n        if (positions) {\n            this.positions = positions;\n        }\n        if (indices) {\n            this.indices = indices;\n        }\n    }\n    BufferGeometry.prototype.setPositions = function (positions) {\n        this.positions = positions;\n        return this;\n    };\n    BufferGeometry.prototype.getPositions = function () {\n        return this.positions;\n    };\n    BufferGeometry.prototype.setIndices = function (indices) {\n        this.indices = indices;\n        return this;\n    };\n    BufferGeometry.prototype.getIndices = function () {\n        return this.indices;\n    };\n    BufferGeometry.prototype.setAttribute = function (name, attribute) {\n        this.attributes[name] = attribute;\n        return this;\n    };\n    BufferGeometry.prototype.getAttribute = function (name) {\n        return this.attributes[name];\n    };\n    /**\n     * Compute smooth vertex normals for the geometry\n     * This method calculates normals by averaging face normals of adjacent triangles\n     */\n    BufferGeometry.prototype.computeVertexNormals = function () {\n        if (!this.positions) {\n            console.warn('Cannot compute vertex normals: no position attribute found');\n            return this;\n        }\n        var positionAttribute = this.positions;\n        var vertexCount = positionAttribute.count;\n        // Initialize normals array with zeros\n        var normals = new Float32Array(vertexCount * 3);\n        // Create or get the normal attribute\n        var normalAttribute = this.getAttribute('normal');\n        if (!normalAttribute) {\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n            this.setAttribute('normal', normalAttribute);\n        }\n        else {\n            // Reset existing normals to zero\n            normals.fill(0);\n            normalAttribute.array = normals;\n        }\n        // Helper vectors for calculations\n        var v0 = [0, 0, 0];\n        var v1 = [0, 0, 0];\n        var v2 = [0, 0, 0];\n        var edge1 = [0, 0, 0];\n        var edge2 = [0, 0, 0];\n        var faceNormal = [0, 0, 0];\n        // Function to calculate cross product\n        var cross = function (a, b, result) {\n            result[0] = a[1] * b[2] - a[2] * b[1];\n            result[1] = a[2] * b[0] - a[0] * b[2];\n            result[2] = a[0] * b[1] - a[1] * b[0];\n        };\n        // Function to subtract vectors\n        var subtract = function (a, b, result) {\n            result[0] = a[0] - b[0];\n            result[1] = a[1] - b[1];\n            result[2] = a[2] - b[2];\n        };\n        // Function to add vectors\n        var add = function (a, b) {\n            a[0] += b[0];\n            a[1] += b[1];\n            a[2] += b[2];\n        };\n        if (this.indices) {\n            // Indexed geometry - iterate through triangles using indices\n            var indexArray = this.indices.array;\n            var triangleCount = indexArray.length / 3;\n            for (var i = 0; i < triangleCount; i++) {\n                var i0 = indexArray[i * 3];\n                var i1 = indexArray[i * 3 + 1];\n                var i2 = indexArray[i * 3 + 2];\n                // Get vertices\n                v0[0] = positionAttribute.getComponent(i0, 0);\n                v0[1] = positionAttribute.getComponent(i0, 1);\n                v0[2] = positionAttribute.getComponent(i0, 2);\n                v1[0] = positionAttribute.getComponent(i1, 0);\n                v1[1] = positionAttribute.getComponent(i1, 1);\n                v1[2] = positionAttribute.getComponent(i1, 2);\n                v2[0] = positionAttribute.getComponent(i2, 0);\n                v2[1] = positionAttribute.getComponent(i2, 1);\n                v2[2] = positionAttribute.getComponent(i2, 2);\n                // Calculate edges\n                subtract(v1, v0, edge1);\n                subtract(v2, v0, edge2);\n                // Calculate face normal (cross product)\n                cross(edge1, edge2, faceNormal);\n                // Add face normal to each vertex normal\n                var n0 = [normals[i0 * 3], normals[i0 * 3 + 1], normals[i0 * 3 + 2]];\n                var n1 = [normals[i1 * 3], normals[i1 * 3 + 1], normals[i1 * 3 + 2]];\n                var n2 = [normals[i2 * 3], normals[i2 * 3 + 1], normals[i2 * 3 + 2]];\n                add(n0, faceNormal);\n                add(n1, faceNormal);\n                add(n2, faceNormal);\n                // Store back in array\n                normals[i0 * 3] = n0[0];\n                normals[i0 * 3 + 1] = n0[1];\n                normals[i0 * 3 + 2] = n0[2];\n                normals[i1 * 3] = n1[0];\n                normals[i1 * 3 + 1] = n1[1];\n                normals[i1 * 3 + 2] = n1[2];\n                normals[i2 * 3] = n2[0];\n                normals[i2 * 3 + 1] = n2[1];\n                normals[i2 * 3 + 2] = n2[2];\n            }\n        }\n        else {\n            // Non-indexed geometry - vertices are stored sequentially in triangles\n            var triangleCount = vertexCount / 3;\n            for (var i = 0; i < triangleCount; i++) {\n                var i0 = i * 3;\n                var i1 = i * 3 + 1;\n                var i2 = i * 3 + 2;\n                // Get vertices\n                v0[0] = positionAttribute.getComponent(i0, 0);\n                v0[1] = positionAttribute.getComponent(i0, 1);\n                v0[2] = positionAttribute.getComponent(i0, 2);\n                v1[0] = positionAttribute.getComponent(i1, 0);\n                v1[1] = positionAttribute.getComponent(i1, 1);\n                v1[2] = positionAttribute.getComponent(i1, 2);\n                v2[0] = positionAttribute.getComponent(i2, 0);\n                v2[1] = positionAttribute.getComponent(i2, 1);\n                v2[2] = positionAttribute.getComponent(i2, 2);\n                // Calculate edges\n                subtract(v1, v0, edge1);\n                subtract(v2, v0, edge2);\n                // Calculate face normal (cross product)\n                cross(edge1, edge2, faceNormal);\n                // For non-indexed geometry, each vertex belongs to only one triangle\n                // so we can directly assign the face normal\n                normals[i0 * 3] = faceNormal[0];\n                normals[i0 * 3 + 1] = faceNormal[1];\n                normals[i0 * 3 + 2] = faceNormal[2];\n                normals[i1 * 3] = faceNormal[0];\n                normals[i1 * 3 + 1] = faceNormal[1];\n                normals[i1 * 3 + 2] = faceNormal[2];\n                normals[i2 * 3] = faceNormal[0];\n                normals[i2 * 3 + 1] = faceNormal[1];\n                normals[i2 * 3 + 2] = faceNormal[2];\n            }\n        }\n        // Normalize all normal vectors\n        for (var i = 0; i < vertexCount; i++) {\n            var x = normals[i * 3];\n            var y = normals[i * 3 + 1];\n            var z = normals[i * 3 + 2];\n            var length_1 = Math.sqrt(x * x + y * y + z * z);\n            if (length_1 > 0) {\n                normals[i * 3] = x / length_1;\n                normals[i * 3 + 1] = y / length_1;\n                normals[i * 3 + 2] = z / length_1;\n            }\n            else {\n                // Handle degenerate case (zero-length normal)\n                normals[i * 3] = 0;\n                normals[i * 3 + 1] = 1;\n                normals[i * 3 + 2] = 0;\n            }\n        }\n        // Update the normal attribute\n        normalAttribute.needsUpdate = true;\n        return this;\n    };\n    return BufferGeometry;\n}());\nexports.BufferGeometry = BufferGeometry;\n// Convenience constructors for different types\n/**\n * Float32BufferAttribute class for handling Float32Array\n * @param array - The typed array (Float32Array or number[])\n * @param itemSize - Number of components per item (e.g., 3 for vec3)\n * @param normalized - Whether the attribute is normalized (default: false)\n */\nvar Float32BufferAttribute = /** @class */ (function (_super) {\n    __extends(Float32BufferAttribute, _super);\n    function Float32BufferAttribute(array, itemSize, normalized) {\n        if (normalized === void 0) { normalized = false; }\n        var typedArray = array instanceof Float32Array ? array : new Float32Array(array);\n        return _super.call(this, typedArray, itemSize, normalized) || this;\n    }\n    return Float32BufferAttribute;\n}(BufferAttribute));\nexports.Float32BufferAttribute = Float32BufferAttribute;\n/**\n * Uint16BufferAttribute class for handling Uint16Array\n * @param array - The typed array (Uint16Array or number[])\n * @param itemSize - Number of components per item (e.g., 3 for vec3)\n * @param normalized - Whether the attribute is normalized (default: false)\n */\nvar Uint16BufferAttribute = /** @class */ (function (_super) {\n    __extends(Uint16BufferAttribute, _super);\n    function Uint16BufferAttribute(array, itemSize, normalized) {\n        if (normalized === void 0) { normalized = false; }\n        var typedArray = array instanceof Uint16Array ? array : new Uint16Array(array);\n        return _super.call(this, typedArray, itemSize, normalized) || this;\n    }\n    return Uint16BufferAttribute;\n}(BufferAttribute));\nexports.Uint16BufferAttribute = Uint16BufferAttribute;\n/**\n * Uint32BufferAttribute class for handling Uint32Array\n * @param array - The typed array (Uint32Array or number[])\n * @param itemSize - Number of components per item (e.g., 3 for vec3)\n * @param normalized - Whether the attribute is normalized (default: false)\n */\nvar Uint32BufferAttribute = /** @class */ (function (_super) {\n    __extends(Uint32BufferAttribute, _super);\n    function Uint32BufferAttribute(array, itemSize, normalized) {\n        if (normalized === void 0) { normalized = false; }\n        var typedArray = array instanceof Uint32Array ? array : new Uint32Array(array);\n        return _super.call(this, typedArray, itemSize, normalized) || this;\n    }\n    return Uint32BufferAttribute;\n}(BufferAttribute));\nexports.Uint32BufferAttribute = Uint32BufferAttribute;\n\n\n//# sourceURL=webpack://KeplerLit/./src/attributes.ts?\n}");

/***/ }),

/***/ "./src/colorMap.ts":
/*!*************************!*\
  !*** ./src/colorMap.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\n/**\n * @author daron1337 / http://daron1337.github.io/\n * @author fmaerten  / https://github.com/xaliphostes\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ColorMap = exports.addColorMap = exports.colorMapNames = exports.createLut = void 0;\nvar Color_1 = __webpack_require__(/*! ./Color */ \"./src/Color.ts\");\nfunction createLut(name, numberofcolors, duplicate) {\n    if (duplicate === void 0) { duplicate = 1; }\n    var map = ColorMapKeywords[name] || ColorMapKeywords.Rainbow;\n    var newMap = [];\n    var start = 0;\n    for (var i = 0; i < duplicate; ++i) {\n        map.forEach(function (m) {\n            // newMap.push([Color.toHexString(start + m[0] / duplicate), m[1]])\n            newMap.push([start + m[0] / duplicate, m[1]]);\n        });\n        start += 1 / duplicate;\n    }\n    return new ColorMap(newMap, numberofcolors);\n}\nexports.createLut = createLut;\nfunction colorMapNames() {\n    var names = [];\n    for (var _i = 0, _a = Object.entries(ColorMapKeywords); _i < _a.length; _i++) {\n        var _b = _a[_i], key = _b[0], value = _b[1];\n        names.push(key);\n    }\n    return names;\n}\nexports.colorMapNames = colorMapNames;\nfunction addColorMap(colormapName, arrayOfColors) {\n    ColorMapKeywords[colormapName] = arrayOfColors;\n}\nexports.addColorMap = addColorMap;\n/**\n * @category Color Lookup Table\n */\nvar ColorMap = /** @class */ (function () {\n    function ColorMap(colormap, numberofcolors) {\n        this.map = [];\n        this.lut = [];\n        this.n = 256;\n        this.minV = 0;\n        this.maxV = 1;\n        this.setColorMap(colormap, numberofcolors);\n    }\n    ColorMap.addColorMap = function (colormapName, arrayOfColors) {\n        ColorMapKeywords[colormapName] = arrayOfColors;\n    };\n    Object.defineProperty(ColorMap.prototype, \"mapColors\", {\n        get: function () {\n            return this.map;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorMap.prototype, \"canvas\", {\n        get: function () {\n            return this.canvas_;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ColorMap.prototype.set = function (value) {\n        if (value instanceof ColorMap) {\n            this.copy(value);\n        }\n        return this;\n    };\n    Object.defineProperty(ColorMap.prototype, \"length\", {\n        get: function () {\n            return this.map.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ColorMap.prototype.setMin = function (min) {\n        this.minV = min;\n        return this;\n    };\n    ColorMap.prototype.setMax = function (max) {\n        this.maxV = max;\n        return this;\n    };\n    ColorMap.prototype.setColorMap = function (colormap, numberofcolors) {\n        if (Array.isArray(colormap)) {\n            this.map = colormap;\n        }\n        else {\n            this.map = ColorMapKeywords[colormap] || ColorMapKeywords.Rainbow;\n        }\n        this.n = numberofcolors || 32;\n        var step = 1.0 / this.n;\n        this.lut = [];\n        for (var i = 0; i <= 1; i += step) {\n            for (var j = 0; j < this.map.length - 1; j++) {\n                if (i >= this.map[j][0] && i < this.map[j + 1][0]) {\n                    var min = this.map[j][0];\n                    var max = this.map[j + 1][0];\n                    // console.log(this.map[j][1], this.map[j + 1][1])\n                    var minColor = new Color_1.Color(this.map[j][1]);\n                    var maxColor = new Color_1.Color(this.map[j + 1][1]);\n                    // console.log(minColor, maxColor)\n                    var color = minColor.lerp(maxColor, (i - min) / (max - min));\n                    this.lut.push(color);\n                }\n            }\n        }\n        return this;\n    };\n    ColorMap.prototype.copy = function (lut) {\n        this.lut = lut.lut;\n        this.map = lut.map;\n        this.n = lut.n;\n        this.minV = lut.minV;\n        this.maxV = lut.maxV;\n        return this;\n    };\n    ColorMap.prototype.getColor = function (alpha) {\n        if (alpha <= this.minV) {\n            alpha = this.minV;\n        }\n        else if (alpha >= this.maxV) {\n            alpha = this.maxV;\n        }\n        alpha = (alpha - this.minV) / (this.maxV - this.minV);\n        var colorPosition = Math.round(alpha * this.n);\n        if (colorPosition === this.n)\n            colorPosition -= 1;\n        return this.lut[colorPosition];\n    };\n    ColorMap.prototype.createCanvas = function (parent, width) {\n        if (parent === void 0) { parent = document; }\n        if (width === void 0) { width = 1; }\n        var canvas = parent.createElement('canvas');\n        canvas.width = width;\n        canvas.height = this.n;\n        this.updateCanvas(canvas);\n        return canvas;\n    };\n    ColorMap.prototype.updateCanvas = function (canvas) {\n        this.canvas_ = canvas;\n        var ctx = canvas.getContext('2d', { alpha: false });\n        var k = 0;\n        var step = 1.0 / this.n;\n        for (var i = 1; i >= 0; i -= step) {\n            for (var j = this.map.length - 1; j >= 0; j--) {\n                if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n                    var min = this.map[j - 1][0];\n                    var max = this.map[j][0];\n                    var minColor = new Color_1.Color(this.map[j - 1][1]);\n                    var maxColor = new Color_1.Color(this.map[j][1]);\n                    var color = minColor.lerp(maxColor, (i - min) / (max - min));\n                    ctx.fillStyle = \"rgb(\".concat(Math.round(color.r * 255), \", \").concat(Math.round(color.g * 255), \", \").concat(Math.round(color.b * 255), \")\");\n                    ctx.fillRect(0, k, 15, 1);\n                    k += 1;\n                }\n            }\n        }\n        return canvas;\n    };\n    return ColorMap;\n}());\nexports.ColorMap = ColorMap;\nvar ColorMapKeywords = {\n    'Cooltowarm': [\n        [0.0, 0x3C4EC2],\n        [0.2, 0x9BBCFF],\n        [0.5, 0xDCDCDC],\n        [0.8, 0xF6A385],\n        [1.0, 0xB40426]\n    ],\n    'Blackbody': [\n        [0.0, 0x000000],\n        [0.2, 0x780000],\n        [0.5, 0xE63200],\n        [0.8, 0xFFFF00],\n        [1.0, 0xFFFFFF]\n    ],\n    'Grayscale': [\n        [0.0, 0x000000],\n        [0.2, 0x404040],\n        [0.5, 0x7F7F80],\n        [0.8, 0xBFBFBF],\n        [1.0, 0xFFFFFF]\n    ],\n    'Insar': [\n        [0.0, 0x0500d5],\n        [0.3, 0x00baff],\n        [0.5, 0x00ffc6],\n        [0.7, 0xfcff00],\n        [1.0, 0xd00000]\n    ],\n    'InsarBanded': [\n        [0, 0x0500d5],\n        [0.02040816326530612, 0x00baff],\n        [0.04081632653061224, 0x00ffc6],\n        [0.061224489795918366, 0xfcff00],\n        [0.08163265306122448, 0xd00000],\n        [0.1020408163265306, 0x0500d5],\n        [0.12244897959183673, 0x00baff],\n        [0.14285714285714285, 0x00ffc6],\n        [0.16326530612244897, 0xfcff00],\n        [0.18367346938775508, 0xd00000],\n        [0.2040816326530612, 0x0500d5],\n        [0.22448979591836732, 0x00baff],\n        [0.24489795918367346, 0x00ffc6],\n        [0.26530612244897955, 0xfcff00],\n        [0.2857142857142857, 0xd00000],\n        [0.3061224489795918, 0x0500d5],\n        [0.32653061224489793, 0x00baff],\n        [0.3469387755102041, 0x00ffc6],\n        [0.36734693877551017, 0xfcff00],\n        [0.3877551020408163, 0xd00000],\n        [0.4081632653061224, 0x0500d5],\n        [0.42857142857142855, 0x00baff],\n        [0.44897959183673464, 0x00ffc6],\n        [0.4693877551020408, 0xfcff00],\n        [0.4897959183673469, 0xd00000],\n        [0.5102040816326531, 0x0500d5],\n        [0.5306122448979591, 0x00baff],\n        [0.5510204081632653, 0x00ffc6],\n        [0.5714285714285714, 0xfcff00],\n        [0.5918367346938775, 0xd00000],\n        [0.6122448979591836, 0x0500d5],\n        [0.6326530612244897, 0x00baff],\n        [0.6530612244897959, 0x00ffc6],\n        [0.673469387755102, 0xfcff00],\n        [0.6938775510204082, 0xd00000],\n        [0.7142857142857142, 0x0500d5],\n        [0.7346938775510203, 0x00baff],\n        [0.7551020408163265, 0x00ffc6],\n        [0.7755102040816326, 0xfcff00],\n        [0.7959183673469387, 0xd00000],\n        [0.8163265306122448, 0x0500d5],\n        [0.836734693877551, 0x00baff],\n        [0.8571428571428571, 0x00ffc6],\n        [0.8775510204081632, 0xfcff00],\n        [0.8979591836734693, 0xd00000],\n        [0.9183673469387754, 0x0500d5],\n        [0.9387755102040816, 0x00baff],\n        [0.9591836734693877, 0x00ffc6],\n        [0.9795918367346939, 0xfcff00],\n        [0.9999999999999999, 0xd00000]\n    ],\n    'Rainbow': [\n        [0.0, 0xff0000],\n        [0.2, 0xfffc00],\n        [0.4, 0x00ff06],\n        [0.6, 0x00fffc],\n        [0.8, 0x0600ff],\n        [1.0, 0xf600ff]\n    ],\n    'Igeoss': [\n        [0.00, 0x003627],\n        [0.10, 0x008A3B],\n        [0.20, 0x68BE0D],\n        [0.30, 0xD6DF00],\n        [0.40, 0xFAD000],\n        [0.50, 0xFFC010],\n        [0.60, 0xFFAE0E],\n        [0.70, 0xFF9B06],\n        [0.80, 0xFA5800],\n        [0.90, 0xE80008],\n        [1.00, 0x880003]\n    ],\n    'Stress': [\n        [0.0, 0x0000FF],\n        [0.33, 0xFFFFFF],\n        [0.331, 0x00C800],\n        [0.66, 0xFFFFFF],\n        [0.661, 0xFF0000],\n        [1.0, 0xFFFFFF]\n    ],\n    'Blue_White_Red': [\n        [0.0, 0x0012ff],\n        [0.5, 0xffffff],\n        [1.0, 0xff0000]\n    ],\n    'Blue_Green_Red': [\n        [0.0, 0x0012ff],\n        [0.25, 0xffffff],\n        [0.5, 0x00ff00],\n        [0.275, 0xffffff],\n        [1.0, 0xff0000]\n    ],\n    'Spectrum': [\n        [0.0000, 0xffffff],\n        [0.1428, 0xff0000],\n        [0.2856, 0xff00fc],\n        [0.4284, 0x0600ff],\n        [0.5712, 0x00f6ff],\n        [0.7140, 0x00ff06],\n        [0.8568, 0xfffc00],\n        [1.0000, 0xff0000]\n    ],\n    'Default': [\n        [0.00, 0x0c00ff],\n        [0.25, 0x00fcff],\n        [0.50, 0x00ff0c],\n        [0.75, 0xf6ff00],\n        [1.00, 0xff0000]\n    ],\n    'Banded': [\n        [0.0000, 0xfff5cd],\n        [0.1666, 0xff9600],\n        [0.1667, 0xceffd1],\n        [0.3333, 0x107100],\n        [0.3334, 0xd4e4fb],\n        [0.5000, 0x015faf],\n        [0.5001, 0xebdefb],\n        [0.6666, 0xc5029e],\n        [0.6667, 0xfff0cb],\n        [0.8333, 0x845d00],\n        [0.8334, 0xf9d8d8],\n        [1.0000, 0xda0000]\n    ]\n};\n\n\n//# sourceURL=webpack://KeplerLit/./src/colorMap.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./Color */ \"./src/Color.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./colorMap */ \"./src/colorMap.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ \"./src/utils.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./IsoContoursFilled */ \"./src/IsoContoursFilled.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./IsoContoursLines */ \"./src/IsoContoursLines.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./attributes */ \"./src/attributes.ts\"), exports);\n\n\n//# sourceURL=webpack://KeplerLit/./src/index.ts?\n}");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromValuesToColors = exports.fromValueToColor = exports.scale = exports.normalize = exports.min = exports.max = exports.minMax = exports.lerp = void 0;\nvar colorMap_1 = __webpack_require__(/*! ./colorMap */ \"./src/colorMap.ts\");\n/**\n * @brief Linearly interpolates between two values. This name is a contraction of \"linear interpolation\"\n * @param t The parameter t is clamped to the range [0, 1]\n * @param min The minimum value\n * @param max The minimum value\n * @example\n * ```ts\n * lerp(0  , 1, 5) // 1\n * lerp(0.5, 1, 5) // 3\n * lerp(1  , 1, 5) // 5\n * ```\n * @category Utils\n */\nvar lerp = function (t, min, max) {\n    if (t < 0 || t > 1)\n        throw new Error(\"t must be clamped to the range [0,1]. Got \".concat(t));\n    return (1 - t) * min + t * max;\n};\nexports.lerp = lerp;\n/**\n * @brief Compute the minimum and maximum value of an array in one pass\n */\nfunction minMax(array) {\n    var m = Number.POSITIVE_INFINITY;\n    var M = Number.NEGATIVE_INFINITY;\n    var n = array.length;\n    for (var i = 0; i < n; ++i) {\n        var a = array[i];\n        if (a < m)\n            m = a;\n        if (a > M)\n            M = a;\n    }\n    return [m, M];\n}\nexports.minMax = minMax;\n/**\n * @brief Compute the maximum value of an array\n */\nfunction max(array) {\n    var m = Number.NEGATIVE_INFINITY;\n    var n = array.length;\n    for (var i = 0; i < n; ++i) {\n        var a = array[i];\n        if (a > m)\n            m = a;\n    }\n    return m;\n}\nexports.max = max;\n/**\n * @brief Compute the minimum value of an array\n */\nfunction min(array) {\n    var m = Number.POSITIVE_INFINITY;\n    var n = array.length;\n    for (var i = 0; i < n; ++i) {\n        var a = array[i];\n        if (a < m)\n            m = a;\n    }\n    return m;\n}\nexports.min = min;\n/**\n * @brief Normalize an array of numbers to the range [0, 1]\n */\nfunction normalize(array) {\n    var m = minMax(array);\n    return array.map(function (v) { return (v - m[0]) / (m[1] - m[0]); });\n}\nexports.normalize = normalize;\n/**\n * @brief Scale an array of numbers by a factor\n */\nfunction scale(array, s) {\n    return array.map(function (v) { return v * s; });\n}\nexports.scale = scale;\n/**\n * @param value The value to transform in to a color using a lookup table\n * @param params An object to deal with min, max, lut, default-color and reverse table.\n * The value **must** be normalized.\n * @returns [reg, green, blue]\n * @category Lookup Table\n */\nfunction fromValueToColor(value, _a) {\n    var _b = _a.min, min = _b === void 0 ? 0 : _b, _c = _a.max, max = _c === void 0 ? 1 : _c, lutTable = _a.lutTable, defaultColor = _a.defaultColor, _d = _a.reverse, reverse = _d === void 0 ? false : _d;\n    if (value < 0 || value > 1) {\n        throw new Error(\"value *must% be normalized. Got \".concat(value));\n    }\n    var w = reverse ? (1.0 - value) : value;\n    if (w >= min && w <= max) {\n        var c = lutTable.getColor(w);\n        return [c.r, c.g, c.b];\n    }\n    return [defaultColor.r, defaultColor.g, defaultColor.b];\n}\nexports.fromValueToColor = fromValueToColor;\n/**\n * @param values\n * @param param1\n * @returns\n * @category Lookup Table\n */\nfunction fromValuesToColors(values, _a) {\n    var defaultColor = _a.defaultColor, lut = _a.lut, _b = _a.duplicateLut, duplicateLut = _b === void 0 ? 1 : _b, _c = _a.min, min = _c === void 0 ? 0 : _c, _d = _a.max, max = _d === void 0 ? 1 : _d, _e = _a.lockLut, lockLut = _e === void 0 ? true : _e, _f = _a.reverse, reverse = _f === void 0 ? false : _f;\n    var lutTable = (lut instanceof colorMap_1.ColorMap ? lut : (0, colorMap_1.createLut)(lut, 32, duplicateLut));\n    var minmax = minMax(values);\n    var vmin = minmax[0];\n    var vmax = minmax[1];\n    if (lockLut) {\n        lutTable.setMin(0).setMax(1);\n    }\n    else {\n        lutTable.setMin(min).setMax(max);\n    }\n    var colors = new Array(3 * values.length).fill(0);\n    values.forEach(function (v, i) {\n        var w = reverse ? (v - vmax) / (vmin - vmax) : (v - vmin) / (vmax - vmin);\n        if (w >= min && w <= max) {\n            var c = lutTable.getColor(w);\n            colors[3 * i] = c.r;\n            colors[3 * i + 1] = c.g;\n            colors[3 * i + 2] = c.b;\n        }\n        else {\n            colors[3 * i] = defaultColor.r;\n            colors[3 * i + 1] = defaultColor.g;\n            colors[3 * i + 2] = defaultColor.b;\n        }\n    });\n    return colors;\n}\nexports.fromValuesToColors = fromValuesToColors;\n\n\n//# sourceURL=webpack://KeplerLit/./src/utils.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});